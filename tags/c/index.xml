<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Vithurshan SELVARAJAH</title><link>https://www.atomicl.net/tags/c/</link><description>Recent content in C on Vithurshan SELVARAJAH</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 21 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.atomicl.net/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>Concurrent Instruction Execution</title><link>https://www.atomicl.net/notes/concurrent_instruction_execution/</link><pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.atomicl.net/notes/concurrent_instruction_execution/</guid><description>The system call fork() is used to create new process which is a exact copy of the caller/parent process and the created process is called child process.
Here is an illustration of creating processes using the fork() function:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #define MAX_COUNT 200 #define BUF_SIZE 100 void main(void) { pid_t pid; int i; char buf[BUF_SIZE]; fork(); pid = getpid(); for (i = 1; i &amp;lt;= MAX_COUNT; i++) { sprintf(buf, &amp;#34;This line is from pid %d, value = %d\n&amp;#34;, pid, i); write(1, buf, strlen(buf)); } } If the above program successfully executes up to the fork() function (marked with an arrow in the following figure):</description></item></channel></rss>