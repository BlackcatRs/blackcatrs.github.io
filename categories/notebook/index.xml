<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notebook on Vithurshan SELVARAJAH</title><link>https://www.atomicl.net/categories/notebook/</link><description>Recent content in Notebook on Vithurshan SELVARAJAH</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 09 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.atomicl.net/categories/notebook/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to Threads</title><link>https://www.atomicl.net/notes/thread/</link><pubDate>Thu, 09 May 2024 00:00:00 +0000</pubDate><guid>https://www.atomicl.net/notes/thread/</guid><description>A process is a set of instructions that is loaded into memory to be executed by a processor or a set of processors. The process description in memory contains all necessary information, such as the Instruction Pointer (also known as the Program Counter), which indicates the next instruction to be executed, as well as registers, variables, file handles, etc., that are needed by the scheduler to execute the program.</description></item><item><title>Concurrent Instruction Execution</title><link>https://www.atomicl.net/notes/concurrent_instruction_execution/</link><pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.atomicl.net/notes/concurrent_instruction_execution/</guid><description>The system call fork() is used to create new process which is a exact copy of the caller/parent process and the created process is called child process.
Here is an illustration of creating processes using the fork() function:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #define MAX_COUNT 200 #define BUF_SIZE 100 void main(void) { pid_t pid; int i; char buf[BUF_SIZE]; fork(); pid = getpid(); for (i = 1; i &amp;lt;= MAX_COUNT; i++) { sprintf(buf, &amp;#34;This line is from pid %d, value = %d\n&amp;#34;, pid, i); write(1, buf, strlen(buf)); } } If the above program successfully executes up to the fork() function (marked with an arrow in the following figure):</description></item><item><title>Linux Process</title><link>https://www.atomicl.net/notes/linux_process/</link><pubDate>Wed, 13 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.atomicl.net/notes/linux_process/</guid><description>Process Creation A process is a running instance of a program, or in other words, representation of a program when executing by the processor.
A program is a file that contains machine code, which can be understood and executed by a processor. It is obtained from code written in some programming language and undergoes a transformation to become machine code and thus a program.
Here is an example of code written in C programming language: #include &amp;lt;stdio.</description></item><item><title>Sécurisation des sauvegardes</title><link>https://www.atomicl.net/notes/securisation_des_sauvegardes/</link><pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate><guid>https://www.atomicl.net/notes/securisation_des_sauvegardes/</guid><description>La stratégie de sauvegarde La définition de la stratégie de sauvegarde est basée principalement sur deux critères, à savoir le Recovery Time Objective (RTO) et le Recovery Point Objective (RPO).
Le RTO définit le temps maximal de tolérance par l&amp;#39;entreprise pour restaurer une sauvegarde en cas d&amp;#39;anomalie.
Le RPO définit la quantité de données que l&amp;#39;entreprise peut se permettre de perdre, ou autrement dit, cela représente la quantité de données que l&amp;#39;on pourrait perdre si l&amp;#39;on restaure la dernière sauvegarde.</description></item></channel></rss>