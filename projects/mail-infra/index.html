<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Build Your Own Mail Infrastructure | Vithurshan SELVARAJAH</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/notes/>Notebook</a></li><li><a href=/categories/>Categories</a></li><li><a href=/projects/>Projects</a></li><li><a href=/index.xml>RSS</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Build Your Own Mail Infrastructure</span></h1><h2 class=date>2024/09/07</h2></div><main><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Introduction</h2><div id=outline-text-headline-1 class=outline-text-2><p>Email is a critical part of communication, both for individuals and businesses. While most people rely on third-party email providers like Gmail, Outlook, or Yahoo, setting up your own mail server on a GNU/Linux system offers several key advantages—greater control, privacy, and customization.</p><p>One of the biggest concerns with using commercial email providers is confidentiality. Your emails pass through third-party servers, where they may be scanned, stored, or even shared for advertising and data analysis purposes. When you run your own mail server, you maintain full control over your messages, ensuring that sensitive communications remain private and secure. This is especially crucial for businesses handling confidential client data, or privacy-conscious individuals who do not want their emails monitored.</p><p>Beyond privacy, owning a mail server allows for advanced customization, better security configurations, and avoiding potential service outages or censorship from big providers. While setting up and maintaining a mail server requires effort and technical knowledge, the benefits of full control over your email far outweigh the challenges.</p><p>In this guide, I’ll walk you through the step-by-step process of setting up your own mail server on a GNU/Linux system, helping you take charge of your communication security.</p><p>Managing mails involves several software component (IMAP, SMTP, Anti-spam), that is why we call it as mail infrastructure instead of a simple mail server.</p><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>How Do Your Users Fetch Emails ?</h3><div id=outline-text-headline-2 class=outline-text-3><p>User connects through IMAP/POP3 protocol to server.</p><p><strong>STEP 1:</strong></p><p>The user usually has a mail client or MUA — Mail User Agent (Thunderbird, Mutt, etc…), that can use the POP3 or IMAP protocol to fetch emails from the server.</p><p>That mail client connects to the POP3 (TCP 110) or IMAP (TCP 143) port on the server and may or may not send the <code>STARTTLS</code> command that initiates an encrypted connection. It then sends the user's username (which is equal to the email address in our case) and their password. POP3 is less used nowadays and lacks of support for multiple folders on the server.</p><p>The client may as well use the secure TLS-encrypted ports directly — 995 for POPs or 993 for IMAPs.</p><p><strong>STEP 2:</strong></p><p>Dovecot sends a query to the MySQL database and verifies that the username and password belong to a known user. If the password is wrong then Dovecot will refuse the login.</p><p>As defined in the Devecot configuration file, each user has a directory where emails are stored. So if the user is named <code class=verbatim>vselvarajah@atomicl.net</code>, Dovecot will look for the mail directory in <code class=verbatim>/var/vmail/atomicl.net/vselvarajah/Maildir/…</code> and save the email in the corresponding mail directory.</p><p><strong>NOTE: We can also integrate a webmail service so users can send/read mails using the browser but we are not going to do that here.</strong></p></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>How Do Users Send Emails ?</h3><div id=outline-text-headline-3 class=outline-text-3><p><img src=./img/Send_mail.jpg alt=./img/Send_mail.jpg title=./img/Send_mail.jpg></p><p><strong>STEP 1:</strong></p><p>The user writes the email using a mail user agent (MUA) such as Thunderbird, Mutt, etc. And clicks on "Send". The mail client establishes an SMTP connection to your Postfix server on port 25 or 587. In most cases, the user's internet service provider blocks port 25 to prevent spam, so users use port 587.</p><p>To ensure that the user is allowed to send emails to other SMTP servers through your system, a username (or email address) and password are required.</p><p>In the guide we instruct Postfix to use encryption for authentication for security reasons, but this is completely optional.</p><p><strong>STEP 2:</strong></p><p>Your Postfix server checks the email address and password in the database. Or it can delegate to another service like Dovecot to handle authentication.</p><p>Then Dovecot sends a query to the MariaDB database to check if the email address and password are correct and tells Postfix the result.</p><p><strong>STEP 3:</strong></p><p>Postftix knows now that it is authorized to send the email on behalf of the user. It tells the user that it successfully accepted the email. The email is put into Postfix’s mail queue for further processing. Postfix will now query a DNS server to determine mail server of recipient. As the recipient has an <code class=verbatim>...@recipient-domain.com</code> email address it checks the MX record of the <code class=verbatim>recipient-domain.com</code> domain and then gets the respective IP address.</p><p><strong>STEP 4:</strong></p><p>Postfix now knows which mail server to send the email to. It opens an SMTP connection and delivers the email.</p></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>How Emails Are Transferred ?</h3><div id=outline-text-headline-4 class=outline-text-3><p><img src=./img/Mail_Infra.jpg alt=./img/Mail_Infra.jpg title=./img/Mail_Infra.jpg></p><p>Les's see how mails get transferred to <code class=verbatim>vselvarajah@atomicl.net</code> recipient from some else.</p><p><strong>STEP 1:</strong></p><ol><li>SENDER's SMTP: Query DNS server for email server of the domain <code class=verbatim>atomicl.net</code>.</li><li>DNS: Checks MX record of <code class=verbatim>atomicl.net</code> domain for mails servers and sends the IP address.</li></ol><p><strong>STEP 2:</strong></p><ol><li>SENDER's SMTP: Connects to that IP on TCP port 25 which is by default used by SMTP server (Simple Mail Transport Protocol)</li><li>MY POSTFIX: Welcome, I am Postfix server. Who is there ? (<code>220 mail.atomicl.net ESMTP Postfix</code>)</li><li>SENDER's SMTP: Hi, I am a remote server. (<code>EHLO mail.sender-domain.com</code>)</li><li>MY POSTFIX: Nice to meet you. I can offer you a few features like pipelining and encryption… (<code>STARTTLS, PIPELINING, SIZE 4000000, …</code>)</li><li>SENDER's SMTP: OK, then we switch to an encrypted connection. (<code>STARTTLS</code>)
<em>The connection is now using TLS encryption.</em></li><li>SENDER's SMTP: I have an email from <code class=verbatim>user@sender-domain.com</code> (<code>MAIL FROM:&lt;user@sender-domain.com></code>)</li><li>MY POSTFIX: I see. (<code>Ok</code>)</li><li>SENDER's SMTP: This email is for <code class=verbatim>vselvarajah@atomicl.net</code> (<code>RCPT TO:&lt;vselvarajah@atomicl.com></code>)</li></ol><p><strong>STEP 3:</strong></p><ol><li>MY POSTFIX: Hi database. (Connects to TCP port 3306 on the local host to talk to MariaDB.) Could you check if <code class=verbatim>atomicl.net</code> is one of our mail domains ? (<code>SELECT … from virtual_domains …</code>)</li><li>MY MariaDB: Yes, I have a that domain in my database.</li><li>MY POSTFIX: Nice. And do you have a mailbox or a forwarding rule for <code class=verbatim>vselvarajah@atomicl.net</code> ? (<code>SELECT … from virtual_aliases/virtual_users …</code>)</li><li>MY MARIADB: Yes, there is a mailbox for that address.</li><li>MY POSTIFX: Remote server, the recipient looks good. (<code>Ok</code>)</li><li>SENDER'S SMTP: Good. Then here’s the actual email. (<code>DATA</code>)
<em>The remote server sends the email header and body.</em></li></ol><p><strong>STEP 4:</strong></p><ol><li>MY POSTFIX: Connects to port 11332 on the local host to reach the <code class=verbatim>rspamd</code>.</li><li><span style=text-decoration:underline>My Postfix:</span> Hi, rspamd. I have a new email. Could you spam check ?</li><li><span style=text-decoration:underline>MY RSPAMD:</span> Sure. Well, there are a few minor issues. But generally the mail looks good. I suggest you accept it.</li></ol><p><strong>STEP 5:</strong></p><ol><li><span style=text-decoration:underline>MY POSTFIX:</span> Hey, remote server. Your email is fine.</li></ol><p><strong>STEP 6:</strong></p><ol><li><span style=text-decoration:underline>MY POSTFIX</span>: Uses a socket file at <code class=verbatim>/var/spool/postfix/private/dovecot-lmtp</code> to talk to Dovecot.</li><li><span style=text-decoration:underline>MY POSTFIX</span>: Hi, Dovecot. Here is a new email for <code class=verbatim>vselvarajah@atomicl.net</code></li><li><span style=text-decoration:underline>MY DOVECOT</span>: Got it.</li></ol><p><strong>STEP 7 (Optional):</strong></p><ol><li>MY DOVECOT: Checks for additional Sieve rules and then stores the email on disk at <code class=verbatim>/var/vmail/atomicl.net/vselvarajah/Maildir/INBOX</code></li></ol></div></div></div></div><div id=outline-container-headline-5 class=outline-2><h2 id=headline-5>Prerequisites</h2><div id=outline-text-headline-5 class=outline-text-2><ol><li><code class=verbatim>GNU/Linux</code> operating system (This guides is uses Debian 12)</li><li><code class=verbatim>Postfix</code> receives incoming emails from the internet and sends out outgoing emails to other mail servers. It is the software that speaks SMTP.</li><li><code class=verbatim>rspamd</code> runs sanity checks on an incoming email to determine whether it is spam.</li><li><code class=verbatim>Dovecot</code> stores emails on your hard disk, applies filters and lets your users fetch their emails using the POP3 and IMAP protocols</li><li><code class=verbatim>MariaDB</code> is a database that stores information about your domains, email aliases and email accounts</li></ol><p>Let's install all required packages:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo apt install mariadb-server postfix postfix-mysql dovecot-mysql dovecot-imapd dovecot-lmtpd mutt certbot ca-certificates telnet swaks</span></span></code></pre></div></div></div></div><div id=outline-container-headline-6 class=outline-2><h2 id=headline-6>About SMTP Server — Postfix</h2><div id=outline-text-headline-6 class=outline-text-2><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>Introduction</h3><div id=outline-text-headline-7 class=outline-text-3><p>The Postfix software is responsible for transferring or receiving mails from other SMTP server using SMTP protocol. It uses a concept called address class to group recipients based on their mail delivery method and only accept mail from domains in the address class. There are three types of address classes:</p><ol><li>Canonical domains (also called local domains)</li><li>Hosted domains (Virtual mailbox domains + Virtual alias domains)</li><li>Relay domains</li></ol><p>And finally there are two mandatory email addresses for every domain that you host. <code class=verbatim>postmaster@domain</code> and <code class=verbatim>abuse@domain</code>. These requirements are documented in RFC 521 and RFC 2142. Be sure to add aliases for them. If an email to those addresses will bounce your domain reputation will suffer.</p></div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>Canonical domains</h3><div id=outline-text-headline-8 class=outline-text-3><p>In most cases, the Postfix systems are the final destination for only a few domain names. These domain names are the host name and/or IP address of the machine that Postfix running on. These domains are called canonical domains.</p><p>Mails to canonical domains are delivered using a Unix-like mail delivery method. It only accepts mail from/to valid user accounts, or in other words, it checks the username in the <code class=verbatim>/etc/passwd</code> file and then stores the mail in the <code class=verbatim>/var/mail/username</code> directory.</p><p>The disadvantage of this address class is that we cannot have a Postfix server responsible for two domains and two mail directories if the recipient's email address is the same. If Postfix receives emails for recipients <code class=verbatim>user1@example1.com</code> and <code class=verbatim>user1@example2.com</code>, it will store both emails in the mail directory <code class=verbatim>/var/mail/user1</code> because of Unix-like mail delivery method.</p></div></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>Hosted domains</h3><div id=outline-text-headline-9 class=outline-text-3><p>Besides the canonical domains, Postfix can be configured to be the final destination for any number of additional domains. These domains are called hosted domains because they are not directly associated with the host name of the machine that Postfix running on.</p><p>We can use a text file, database or LDAP to specify the domains that Postfix is ​​responsible for, the email address and the mail directory of the recipient on disk to store the emails.</p><p>Postfix expects this data in the form of a mapping. The mapping is a two-column table, the left column is considered the key and the right column is considered the value. Here is an example mapping that shows valid email addresses and the path to the mail directory on disk:</p><table><thead><tr><th>Virtual mailbox (key)</th><th>Virtual mailbox location on disk (value)</th></tr></thead><tbody><tr><td>user1@example1.com</td><td>/var/vmail/example1.com/user1/Maildir</td></tr><tr><td>user2@example1.com</td><td>/var/vmail/example1.com/user2/Maildir</td></tr><tr><td>user1@example2.com</td><td>/var/vmail/example2.com/user1/Maildir</td></tr></tbody></table><p>Before checking if a specific email address is valid, Postfix first checks if it is responsible for the domain. This is done by the following mapping:</p><table><thead><tr><th>Virtual domain</th><th>Whatever</th></tr></thead><tbody><tr><td>example1.com</td><td>xxxx</td></tr><tr><td>example2.com</td><td>yyyy</td></tr></tbody></table><p>Note the second column which contains a random string because Postfix expects the data to be in form of mapping, but it will not use the second column data when checking for a valid domain.</p><p>These all you need to get a functional mail server. However Postfix provides another useful feature called aliases. An alias is a redirection (or forwarding) of one email address to one or more other addresses.</p><table><tbody><tr><td>Virtual email address</td><td>Redirect to</td></tr><tr><td>postmaster@example.org</td><td>user1@example1.com</td></tr><tr><td>jack@example.com</td><td>user1@example1.com,user1y@example2.com</td></tr></tbody></table><ol><li>Redirect emails for postmaster@example.org to <code class=verbatim>user1@example.org</code>.</li><li>Keep a copy of an incoming email for <code class=verbatim>user1@example.com</code> in his mailbox and send another copy to <code class=verbatim>user@example2.com</code>. You can use multiple email addresses seperated by commas.</li></ol></div></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>Relay domains</h3><div id=outline-text-headline-10 class=outline-text-3><p>Relay domains are domains for which the Postfix does not handle delivery but forwards it to another specified SMTP server.</p></div></div></div></div><div id=outline-container-headline-11 class=outline-2><h2 id=headline-11>About IMAP Server — Dovecot</h2><div id=outline-text-headline-11 class=outline-text-2><p>Dovecot is a software that:</p><ul><li>Gets emails destined to your users from Postfix and saves them to disk.</li><li>Executes user-based sieve filter rules (e.g. move emails to different folders based on certain criteria or to send automated vacation responses).</li><li>Allows the user to fetch emails using POP3 or IMAP protocol.</li></ul></div></div><div id=outline-container-headline-12 class=outline-2><h2 id=headline-12>Obtain a TLS Certificate</h2><div id=outline-text-headline-12 class=outline-text-2><p>We need a TLS certificate to encrypt communication. It will be used in two places:</p><ol><li>Postfix (to encrypt SMTP communication where possible)</li><li>Dovecot (to encrypt IMAP communication and deny any unencrypted traffic)</li></ol><p>But before requesting a certificate from the CA, we need to choose a hostname for the mail server.</p><div id=outline-container-headline-13 class=outline-3><h3 id=headline-13>Choosing a Hostname for Mail Server</h3><div id=outline-text-headline-13 class=outline-text-3><p>A certificate is issued for a fully qualified domain name like <code class=verbatim>mail.example.com</code> and it will be assigned to the <code class=verbatim>Common Name (CN)</code> attribute in a certificate. This attribute must correspond the hostname during communication, otherwise the certificate will be rejected. But a mail server can be responsible for multiple domain names.</p><p><strong>So what to do ?</strong></p><p><span style=text-decoration:underline>Solution 1:</span> A generic name and a single certificate
The simple solution is to chose a generic name. Some mail provider uses the name <code class=verbatim>mail.domain-name.com</code> for all customers and all domains hosted on their mail server.</p><p>Most users do not care about the host name as long as they get their emails. So I would generally recommend this approach due to its simplicity.</p><p><span style=text-decoration:underline>Solution 2:</span> Multiple names/certificates & SNI
Some people however want to give their mail server as many names as they have domains. Suppose that you have three domains: <code class=verbatim>example1.com</code>, <code class=verbatim>example2.com</code> and <code class=verbatim>example3.com</code>. Users of <code class=verbatim>example1.com</code> can use <code class=verbatim>mail.example1.com</code> while users of <code class=verbatim>example2.com</code> use <code class=verbatim>mail.example2.com</code>.</p><p>As you can imagine this would not work if you had a single certificate because the latter can contain only one CN. If your CN is <code class=verbatim>mail.example1.com</code> then talking to your server by the name <code class=verbatim>mail.example2.com</code> would lead to a certificate error.</p><p>So your mail server needs multiple certificates – one for each host name. And depending on how a user connects to your server you need to send the matching certificate. If the user wants to speak to <code class=verbatim>mail.example1.com</code> then your server needs to send the certificate with CN <code class=verbatim>mail.example1.com</code>.</p><p>Fortunately that problem has been addressed by a technique called <code class=verbatim>Server Name Indication (SNI)</code>. A client talks to the server and even before the encrypted connection is established it tells the server that it expects a certificate for the intended host name. The server can then load the matching certificate and initiate the encryption process.</p><p>SNI has long been a problem for mail servers. The mail user agent (e.g. Thunderbird) needs to support it as well as Postfix and Dovecot. Postfix has finally added SNI in version 3.4 so that we can use it.</p><p>While adding multiple host names needs extra work, it also has a benefit. If you want to move domains to other servers (e.g. when upgrading your server) you can move one domain at a time.</p></div></div><div id=outline-container-headline-14 class=outline-3><h3 id=headline-14>Obtain a Let's Encrypt Certificate</h3><div id=outline-text-headline-14 class=outline-text-3><p>Here we are using Let's Encrypt as a Certificate Authority to sign the certificate we are going to generate. We will use the certbot tool to request an encryption certificate from LetsEncrypt and it will ask us to prove ownership of the domain we are requesting a certificate for.</p><p>The process of obtaining the certificate will be as follows:</p><ol><li>Certbot creates a private key and a certificate request. It sends the certificate request to the LetsEncrypt server.</li><li>The LetsEncrypt server replies with a challenge/token.</li><li>Certbot puts that token into a file in the <code class=verbatim>/var/www/webmail.example.org/.well-known/acme-challenge</code> directory.</li><li>The LetsEncrypt server does an HTTP connection to <a href=http://example.com/.well-known/acme-challenge/...>http://example.com/.well-known/acme-challenge/...</a> and expects to find that token. This verifies that you are in charge of the domain and the web server.</li><li>If all works well the LetsEncrypt server signs your certificate request and thus creates the actual certificate.</li><li>Certbot receives the certificate and puts it into <code class=verbatim>/etc/letsencrypt/archive/webmail.example.org/</code></li></ol><div id=outline-container-headline-15 class=outline-4><h4 id=headline-15>Method 1 — Generating a LetsEncrypt Certificate (Apache Web Server)</h4><div id=outline-text-headline-15 class=outline-text-4><p>You need to have an Apache virtual host for <code class=verbatim>mail.example.com</code> before obtaining Let’s Encrypt TLS certificate. Create the virtual host file:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>sudo nano /etc/apache2/sites-available/mail.your-domain.com.conf</span></span></code></pre></div></div><p>Then add the following text into the file:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&lt;VirtualHost *:80&gt;        
</span></span><span style=display:flex><span>        ServerName mail.example.com
</span></span><span style=display:flex><span>        DocumentRoot /var/www/html/
</span></span><span style=display:flex><span>&lt;/VirtualHost&gt;</span></span></code></pre></div></div><p>Save and close the file. Enable this virtual host:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>sudo a2ensite mail.your-domain.com.conf</span></span></code></pre></div></div><p>Then disable the default virtual host, because it might interfere with other virtual hosts:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>sudo a2dissite 000-default</span></span></code></pre></div></div><p>Reload Apache for the changes to take effect:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>sudo systemctl reload apache2</span></span></code></pre></div></div><p>Let’s check if the configuration works. Put a test file into your web root directory:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Just a test&#34;</span> &gt; /var/www/example.com/test</span></span></code></pre></div></div><p>Finally send a HTTP request to <a href=http://mail.example.com/test>http://mail.example.com/test</a> endpoint to test the web server.</p><p>Now we are ready request a certificate for the domain:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  certbot certonly --webroot --webroot-path /var/www/example.com -d example.com</span></span></code></pre></div></div><ul><li><code class=verbatim>-d</code>: Domain name</li></ul></div></div><div id=outline-container-headline-16 class=outline-4><h4 id=headline-16>Method 2 — Generating a LetsEncrypt Certificate (Standalone)</h4><div id=outline-text-headline-16 class=outline-text-4><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo certbot certonly -d noradrenaline.atomicl.net -m vselvarajah@atomicl.net --standalone --agree-tos --no-eff-email</span></span></code></pre></div></div><ul><li><code class=verbatim>--agree-tos</code>: Agree to terms of service.</li><li><code class=verbatim>--no-eff-email</code>: Don’t receive emails from EFF foundation.</li><li><code class=verbatim>-d</code>: Host for which requesting a certificate.</li></ul></div></div></div></div><div id=outline-container-headline-17 class=outline-3><h3 id=headline-17>Automatic Certificate Renewal</h3><div id=outline-text-headline-17 class=outline-text-3><p>The certbot package automatically adds a timed job that runs twice a day at random times. The random part is important to avoid millions of server hammering the LetsEncrypt service at the same second.</p><p>Cerbot uses Systemd timer instead of a Cron job. You can find the timer definition in the <code class=verbatim>/lib/systemd/system/certbot.timer</code> file. That timer triggers the renewal service defined in <code class=verbatim>/lib/systemd/system/certbot.service</code>. To find out if the service has run and when the next occurence will be, run <code>systemctl status certbot.timer</code>.</p><p>There is also a Cron file at <code class=verbatim>/etc/cron.d/certbot</code> but it do nothing due to the <code class=verbatim>-d /run/systemd/system</code> condition that checks if systemd is installed. And majority of GNU/Linux systems nowadays uses systemd.</p><p>So the renewal already happens automatically. Should it fail then LetsEncrypt start sending you reminder emails that your certificate should be renewed. That’s a clear sign that something went wrong with the automatic renewal.</p><p>There is one puzzle piece missing though. Even if the renewal worked, it will only update the certificate files. But the software components – Postfix and Dovecot – will not notice the change. So we need to add a so called post-hook to certbot that triggers a restart of all processes thereafter.</p><p>For that purpose edit the <code class=verbatim>/etc/letsencrypt/cli.ini</code> file and add:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>post-hook <span style=color:#f92672>=</span> systemctl restart postfix dovecot apache2</span></span></code></pre></div></div><p>You have implemented Let’s Encrypt for all your services now. Let’s move on.</p></div></div></div></div><div id=outline-container-headline-18 class=outline-2><h2 id=headline-18>Configure Database — MySQL</h2><div id=outline-text-headline-18 class=outline-text-2><p>In this section we will create a database <code class=verbatim>mailserver</code> and two users. The first user <code class=verbatim>mailadmin</code> will be able to modify the database data and is intended for mail server administrator. The other user <code class=verbatim>mailserver</code> can only read the database data and is intended for server processes.</p><p>First we need to create two random passwords for these users using the pwgen tool:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  pwgen -s1 <span style=color:#ae81ff>30</span> <span style=color:#ae81ff>2</span></span></span></code></pre></div></div><p>Take a note of the passwords or store them somewhere safe.</p><p>Connect to the database:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo mysql</span></span></code></pre></div></div><p>Create a database:</p><div class="src src-sql"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>  <span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>DATABASE</span> mailserver;</span></span></code></pre></div></div><p>Now we have an empty database. Let's create the user <code class=verbatim>mailadmin</code> and give the necessary privileges to manage the database:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>grant all on mailserver.* to <span style=color:#e6db74>&#39;mailadmin&#39;</span>@<span style=color:#e6db74>&#39;localhost&#39;</span> identified by <span style=color:#e6db74>&#39;gefk6lA2brMOeb8eR5WYaMEdKDQfnF&#39;</span>;</span></span></code></pre></div></div><p><strong>CAREFUL: Please use the first password you just generated instead of mine.</strong></p><p>Also create the read-only user that will be used by Postfix and Dovecot to access the database:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>grant <span style=color:#66d9ef>select</span> on mailserver.* to <span style=color:#e6db74>&#39;mailserver&#39;</span>@<span style=color:#e6db74>&#39;127.0.0.1&#39;</span> identified by <span style=color:#e6db74>&#39;x893dNj4stkHy1MKQq0USWBaX4ZZdq&#39;</span>;</span></span></code></pre></div></div><p><strong>CAREFUL: Use your second random password here instead of mine.</strong></p><p><em>NOTE:
/Here we are using <code class=verbatim>127.0.0.1</code> instead of <code class=verbatim>localhost</code> because MariaDB (and Oracle’s MySQL) distinguishes between the two. If you initiate a database connection to <code class=verbatim>localhost</code> then you talk to the socket file which lives at <code class=verbatim>/var/run/mysqld/mysqld.sock</code> on your server. But if you connect to <code class=verbatim>127.0.0.1</code> it will create a network connection talking to the TCP socket on port 3306 on your server.</em>
<em>The difference is that any process on your server can talk to 127.0.0.1. But the socket file has certain <code class=verbatim>user/group/other</code> permissions just like any other file on your file system.</em>
<em>Postfix will be restricted to its <code class=verbatim>/var/spool/postfix</code> directory and cannot by default access that socket file. So by using 127.0.0.1 we circumvent that limitation.</em></p><p>Let's create tables to store virtual domains, virtual aliases and virtual users. This table just holds the list of domains that you will use as <code class=verbatim>virtual_mailbox_domains</code> in Postfix:</p><div class="src src-sql"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>USE mailserver;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>EXISTS</span> <span style=color:#f92672>`</span>virtual_domains<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> auto_increment,
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>name<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>50</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span> <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>)
</span></span><span style=display:flex><span> ) ENGINE<span style=color:#f92672>=</span>InnoDB <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8;</span></span></code></pre></div></div><p>The next table contains information about your users:</p><div class="src src-sql"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>EXISTS</span> <span style=color:#f92672>`</span>virtual_users<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> auto_increment,
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>domain_id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>email<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>100</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>password<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>150</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>quota<span style=color:#f92672>`</span> bigint(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span> <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>),
</span></span><span style=display:flex><span> <span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>email<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>email<span style=color:#f92672>`</span>),
</span></span><span style=display:flex><span> <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (domain_id) <span style=color:#66d9ef>REFERENCES</span> virtual_domains(id) <span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>DELETE</span> <span style=color:#66d9ef>CASCADE</span>
</span></span><span style=display:flex><span> ) ENGINE<span style=color:#f92672>=</span>InnoDB <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8;</span></span></code></pre></div></div><p>The last table contains forwardings from an email address to other email addresses:</p><div class="src src-sql"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>EXISTS</span> <span style=color:#f92672>`</span>virtual_aliases<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> auto_increment,
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>domain_id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span><span style=color:#66d9ef>source</span><span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>100</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>destination<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>100</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span> <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>),
</span></span><span style=display:flex><span> <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (domain_id) <span style=color:#66d9ef>REFERENCES</span> virtual_domains(id) <span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>DELETE</span> <span style=color:#66d9ef>CASCADE</span>
</span></span><span style=display:flex><span> ) ENGINE<span style=color:#f92672>=</span>InnoDB <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8;</span></span></code></pre></div></div><div id=outline-container-headline-19 class=outline-3><h3 id=headline-19>Example Data</h3><div id=outline-text-headline-19 class=outline-text-3><p>Let’s populate the database with an <code class=verbatim>example1.com</code> domain, a <code class=verbatim>user1@example1.com</code> email account and a forwarding of <code class=verbatim>postmaster@example1.com</code> to <code class=verbatim>user1@example1.com</code>.</p><p>To add that sample data just run these SQL queries:</p><div class="src src-sql"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>INTO</span> mailserver.virtual_domains (id,name) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;1&#39;</span>,<span style=color:#e6db74>&#39;example1.com&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>INTO</span> mailserver.virtual_users (id,domain_id,password,email)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;{BLF-CRYPT}$2y$05$4OM6TTQ45gXcMcgtfiwdd.FwaeY8lOu3xaYxChjmg/vpyOPTnEpTK&#39;</span>, <span style=color:#e6db74>&#39;user1@example1.com&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>INTO</span> mailserver.virtual_aliases (id,domain_id,<span style=color:#66d9ef>source</span>,destination)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;postmaster@example1.com&#39;</span>, <span style=color:#e6db74>&#39;user1@example1.com&#39;</span>);</span></span></code></pre></div></div><p>The string used in the password column is a secure hash of the simple password <code class=verbatim>SecurePass</code> and is generated using the following command:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  doveadm pw -s BLF-CRYPT</span></span></code></pre></div></div><p>Once you have installed Dovecot you can try that yourself but you will get a different output. The reason is that the passwords are salted to increase their security.</p><p>Don't forget to delete this sample data before putting your mail server into production. With the delete cascade, you only need to delete the virtual domain. The alias and mailbox will be automatically deleted. Here is the SQL query you need to run before putting your mail server into production:</p><div class="src src-sql"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>DELETE</span> <span style=color:#66d9ef>FROM</span> mailserver.virtual_domains <span style=color:#66d9ef>WHERE</span> name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;example1.com&#39;</span>;</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-20 class=outline-2><h2 id=headline-20>Configure Postfix</h2><div id=outline-text-headline-20 class=outline-text-2><div id=outline-container-headline-21 class=outline-3><h3 id=headline-21>Configure Domain</h3><div id=outline-text-headline-21 class=outline-text-3><p>Postfix receives an email for <code class=verbatim>user1@example1.com</code> and wants to find out if <code class=verbatim>example1.com</code> is a virtual mailbox domain. It will run the below SQL query and replace <code class=verbatim>%s</code> by <code class=verbatim>example1.com</code>. If it finds such a row in the <code class=verbatim>virtual_domains</code> table it will return a <code class=verbatim>1</code>. Actually it does not matter what exactly is returns as long as there is a result.</p><p>Edit the file <code class=verbatim>/etc/postfix/mysql-virtual-mailbox-domains.cf</code>:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>user = mailserver
</span></span><span style=display:flex><span>password = x893dNj4stkHy1MKQq0USWBaX4ZZdq
</span></span><span style=display:flex><span>hosts = 127.0.0.1
</span></span><span style=display:flex><span>dbname = mailserver
</span></span><span style=display:flex><span>query = SELECT 1 FROM virtual_domains WHERE name=&#39;%s&#39;</span></span></code></pre></div></div><p>Now you need to make Postfix use this database mapping. The <code class=verbatim>postconf</code> command adds configuration lines to <code class=verbatim>/etc/postfix/main.cf</code> file. It also activates the new setting instantly so you do not have to reload the Postfix process:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postconf virtual_mailbox_domains<span style=color:#f92672>=</span>mysql:/etc/postfix/mysql-virtual-mailbox-domains.cf</span></span></code></pre></div></div><p>The test data you created earlier added the domain <code class=verbatim>example1.com</code> as one of your mailbox domains. Let’s ask Postfix if it recognizes that domain:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postmap -q example1.com mysql:/etc/postfix/mysql-virtual-mailbox-domains.cf</span></span></code></pre></div></div></div></div><div id=outline-container-headline-22 class=outline-3><h3 id=headline-22>Configure User</h3><div id=outline-text-headline-22 class=outline-text-3><p>You will now define the <code class=verbatim>virtual_mailbox_maps</code>. It will map a recipient’s email address to the location of the user’s mailbox on your hard disk. Postfix has a built-in transport service called <code class=verbatim>virtual</code> that can receive the email and store it into the recipient’s email directory. That service is pretty limited, so we will delegate that to Dovecot as it allows us better control.</p><p>Postfix will forward all emails to Dovecot for further delivery. But we need to make sure that the recipient actually exists before we do that. So Postfix needs to check whether an email address belongs to a valid mailbox.</p><p>We need an SQL query that searches for an email address and returns <code class=verbatim>1</code> if it is found. To accomplish that please create another configuration file at <code class=verbatim>/etc/postfix/mysql-virtual-mailbox-maps.cf</code>:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>user <span style=color:#f92672>=</span> mailserver
</span></span><span style=display:flex><span>password <span style=color:#f92672>=</span> x893dNj4stkHy1MKQq0USWBaX4ZZdq
</span></span><span style=display:flex><span>hosts <span style=color:#f92672>=</span> 127.0.0.1
</span></span><span style=display:flex><span>dbname <span style=color:#f92672>=</span> mailserver
</span></span><span style=display:flex><span>query <span style=color:#f92672>=</span> SELECT <span style=color:#ae81ff>1</span> FROM virtual_users WHERE email<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;%s&#39;</span></span></span></code></pre></div></div><p>Tell Postfix that this mapping file is supposed to be used for the <code class=verbatim>virtual_mailbox_maps</code> mapping:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postconf virtual_mailbox_maps<span style=color:#f92672>=</span>mysql:/etc/postfix/mysql-virtual-mailbox-maps.cf</span></span></code></pre></div></div><p>Test if Postfix is happy with this mapping by asking it where the mailbox directory of our <code class=verbatim>user1@example.com</code> user would be:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postmap -q user1@example1.com mysql:/etc/postfix/mysql-virtual-mailbox-maps.cf</span></span></code></pre></div></div><p>Again you should get <code class=verbatim>1</code> back which means that <code class=verbatim>user1@example1.com</code> is an existing virtual mailbox user on your server.</p></div></div><div id=outline-container-headline-23 class=outline-3><h3 id=headline-23>Configure Alias</h3><div id=outline-text-headline-23 class=outline-text-3><p>Here your are going to define <code class=verbatim>virtual_alias_maps</code> mapping which is used for forwarding emails from one email address to one or more others. In the database multiple targets are achieved by using multiple rows.</p><p>Create another file at <code class=verbatim>/etc/postfix/mysql-virtual-alias-maps.cf</code>:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>user = mailserver
</span></span><span style=display:flex><span>password = x893dNj4stkHy1MKQq0USWBaX4ZZdq
</span></span><span style=display:flex><span>hosts = 127.0.0.1
</span></span><span style=display:flex><span>dbname = mailserver
</span></span><span style=display:flex><span>query = SELECT destination FROM virtual_aliases WHERE source=&#39;%s&#39;</span></span></code></pre></div></div><p>Make Postfix use this database mapping:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postconf virtual_alias_maps<span style=color:#f92672>=</span>mysql:/etc/postfix/mysql-virtual-alias-maps.cf</span></span></code></pre></div></div><p>Test if the mapping file works as expected:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postmap -q postmaster@example1.com mysql:/etc/postfix/mysql-virtual-alias-maps.cf</span></span></code></pre></div></div><p>You should see the expected destination:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  user1@example1.com</span></span></code></pre></div></div><p>So if Postfix receives an email for <code class=verbatim>postmaster@example1.com</code> it will redirect it to <code class=verbatim>user1@example1.com</code>.</p></div></div><div id=outline-container-headline-24 class=outline-3><h3 id=headline-24>Fix Permissions</h3><div id=outline-text-headline-24 class=outline-text-3><p>We need to make sure that only <code class=verbatim>root</code> and the <code class=verbatim>postfix</code> user can read the <code class=verbatim>.cf</code> files because database password is stored these files:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  chgrp postfix /etc/postfix/mysql-*.cf
</span></span><span style=display:flex><span>  chmod u<span style=color:#f92672>=</span>rw,g<span style=color:#f92672>=</span>r,o<span style=color:#f92672>=</span> /etc/postfix/mysql-*.cf</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-25 class=outline-2><h2 id=headline-25>Configure Dovecot</h2><div id=outline-text-headline-25 class=outline-text-2><div id=outline-container-headline-26 class=outline-3><h3 id=headline-26>Configure Mailbox Owner</h3><div id=outline-text-headline-26 class=outline-text-3><p>First we need to create a new system user that will own all virtual mailboxes for security reasons. The following shell commands will create a system group <code class=verbatim>vmail</code> with group ID (GID) <code class=verbatim>5000</code> and a system user <code class=verbatim>vmail</code> with user ID (UID) <code class=verbatim>5000</code>. Make sure that UID and GID are not yet used or choose another – the number can be anything between 1000 and 65000 that is not yet used:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo groupadd -g <span style=color:#ae81ff>5000</span> vmail
</span></span><span style=display:flex><span>  sudo useradd -g vmail -u <span style=color:#ae81ff>5000</span> vmail -d /var/vmail -m
</span></span><span style=display:flex><span>  sudo chown -R vmail:vmail /var/vmail</span></span></code></pre></div></div></div></div><div id=outline-container-headline-27 class=outline-3><h3 id=headline-27>Prerequisites</h3><div id=outline-text-headline-27 class=outline-text-3><p>Make sure this line exist in the <code class=verbatim>/etc/dovecot/dovecot.conf</code>:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>!include conf.d/*.conf</span></span></code></pre></div></div></div></div><div id=outline-container-headline-28 class=outline-3><h3 id=headline-28>Authentication Mechanism</h3><div id=outline-text-headline-28 class=outline-text-3><p>Edit <code class=verbatim>/etc/dovecot/conf.d/10-auth.conf</code> and add :</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>auth_mechanisms = plain login</span></span></code></pre></div></div><ul><li>You need to add the <code class=verbatim>login</code> mechanism if you have Outlook users.</li></ul><p>These two mechanisms would ask for a password without enforcing encryption. But by default, Dovecot sets <code class=verbatim>disable_plaintext_auth = yes</code> which ensures that authentication is only accepted over TLS-encrypted connections.</p><p>At the end of this file you will find various authentication backends that Dovecot ships with. By default it will use system users (those from the <code class=verbatim>/etc/passwd</code>). But we want to use the MariaDB database backend so go ahead and change this block to:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>#!include auth-system.conf.ext
</span></span><span style=display:flex><span>!include auth-sql.conf.ext
</span></span><span style=display:flex><span>#!include auth-ldap.conf.ext
</span></span><span style=display:flex><span>#!include auth-passwdfile.conf.ext
</span></span><span style=display:flex><span>#!include auth-checkpassword.conf.ext
</span></span><span style=display:flex><span>#!include auth-static.conf.ext</span></span></code></pre></div></div></div></div><div id=outline-container-headline-29 class=outline-3><h3 id=headline-29>Set Mailbox Locations</h3><div id=outline-text-headline-29 class=outline-text-3><p>Change the mail_location in <code class=verbatim>/etc/dovecot/conf.d/10-mail.conf</code> to:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>mail_location = maildir:~/Maildir</span></span></code></pre></div></div><p>This is the directory where Dovecot will look for the emails of a specific user. The tilde character (<code class=verbatim>~</code>) means the user’s home directory. That does not make sense yet. But further down on this page we will tell Dovecot what the home directory is supposed to mean. For example <code class=verbatim>user1@example.org</code> will have his home directory in <code class=verbatim>/var/vmail/example1.org/user1</code>.</p><p><em>NOTE: Further down in the <code class=verbatim>10-mail.conf</code> file you will find sections defining the namespaces <sup class=footnote-reference><a id=footnote-reference-1 href=#footnote-1>1</a></sup>. Those are folder structures that your email client sees when connecting to the mail server. If you use POP3 you can only access the <code class=verbatim>inbox</code> – which is where all incoming email is stored. Using the IMAP protocol you get access to a hierarchy of folders and subfolders. And you can even share folders between users. Or use a public folder that can be accessed by anyone – even anonymously. So IMAP is generally to be preferred.</em></p></div></div><div id=outline-container-headline-30 class=outline-3><h3 id=headline-30>Service and Authentication Socket Configuration</h3><div id=outline-text-headline-30 class=outline-text-3><p>Edit the <code class=verbatim>/etc/dovecot/conf.d/10-master.conf</code> file which deals with typical service ports like IMAP or POP3.</p><p><em>NOTE: Don’t worry about the standard unencrypted TCP ports 110 (for POP3) and 143 (for IMAP). They can be kept activated. If a user connects to these ports they will have to issue a <code>STARTTLS</code> command to switch into encrypted mode before they are allowed to send their password. There is basically no difference between using an plaintext port like 110 for POP3 and then using STARTTLS – or connecting to the encrypted 995 port for POP3s (secure).</em></p><p>A change is needed in the <code class=verbatim>service auth {...}</code> section because we want Postfix to allow Dovecot as an authentication service. Add the following lines in the previously mentioned section:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># Postfix smtp-auth
</span></span><span style=display:flex><span>unix_listener /var/spool/postfix/private/auth {
</span></span><span style=display:flex><span>  mode = 0660
</span></span><span style=display:flex><span>  user = postfix
</span></span><span style=display:flex><span>  group = postfix
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div></div><div id=outline-container-headline-31 class=outline-3><h3 id=headline-31>Certificate</h3><div id=outline-text-headline-31 class=outline-text-3><p>Earlier in this guide we created both a key and a certificate file to encrypt the communication with POP3 and IMAPs between the users and your mail server.</p><p>Edit the file <code class=verbatim>/etc/dovecot/conf.d/10-ssl.conf</code> to configure the certificate and key file path:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ssl_cert = &lt;/etc/letsencrypt/live/example1.com/fullchain.pem
</span></span><span style=display:flex><span>ssl_key = &lt;/etc/letsencrypt/live/example1.com/privkey.pem</span></span></code></pre></div></div><p>And enforce TLS encryption by setting:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  ssl = required</span></span></code></pre></div></div></div></div><div id=outline-container-headline-32 class=outline-3><h3 id=headline-32>User Authentication</h3><div id=outline-text-headline-32 class=outline-text-3><p>Dovecot reads the <code class=verbatim>/etc/dovecot/conf.d/auth-sql.conf.ext</code> which defines how to find user information in your database. There are two sections in this file:</p><ol><li><code class=verbatim>userdb</code>: where to find a user’s mailbox in the file system</li><li><code class=verbatim>passdb</code>: where to find the user’s hashed password</li></ol><p>By default Dovecot will run two queries at your database. One for the userdb that gets information like the user ID, group ID, home directory and quota. And another for the passdb that gets the hashed password.</p><p>The <code class=verbatim>userdb</code> section already reads:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>userdb {
</span></span><span style=display:flex><span>   driver = sql
</span></span><span style=display:flex><span>   args = /etc/dovecot/dovecot-sql.conf.ext
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>As you can see Dovecot uses an SQL database lookup to get that information. Edit the file <code class=verbatim>/etc/dovecot/dovecot-sql.conf.ext</code> for more information. You will find this file well documented although all configuration directives are commented out. Add these lines at the bottom of the file:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>driver = mysql
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>connect = \
</span></span><span style=display:flex><span>  host=127.0.0.1 \
</span></span><span style=display:flex><span>  dbname=mailserver \
</span></span><span style=display:flex><span>  user=mailserver \
</span></span><span style=display:flex><span>  password=x893dNj4stkHy1MKQq0USWBaX4ZZdq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>user_query = SELECT email as user, \
</span></span><span style=display:flex><span>  concat(&#39;*:bytes=&#39;, quota) AS quota_rule, \
</span></span><span style=display:flex><span>  &#39;/var/vmail/%d/%n&#39; AS home, \
</span></span><span style=display:flex><span>  5000 AS uid, 5000 AS gid \
</span></span><span style=display:flex><span>  FROM virtual_users WHERE email=&#39;%u&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>password_query = SELECT password FROM virtual_users WHERE email=&#39;%u&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iterate_query = SELECT email AS user FROM virtual_users</span></span></code></pre></div></div><p><em>NOTE: Ending a line with a backslash (<code class=verbatim>\</code>) means that it is continued on the next line. It keeps the configuration more readable.</em></p><p>What these lines mean:</p><ul><li><code class=verbatim>driver</code>: The kind of database. MariaDB is the same kind as MySQL.</li><li><code class=verbatim>connect</code>: Information to access MySQL database (username, password, etc…)</li><li><code class=verbatim>user_query</code>: An SQL query that returns the user name (the email address), the quota, the home directory, user ID and group ID.</li><li><code class=verbatim>password_query</code>: this SQL query just gets the password hash from the database</li><li><code class=verbatim>iterate_query</code>: "doveadm" uses this query to get a list of all users. That allows you to use the <code>doveadm user '*'</code> command later.</li></ul><p>The <code class=verbatim>user_query</code> gets several pieces of information from the database:</p><ul><li><code class=verbatim>email AS user</code>: It gets the the <code class=verbatim>email</code> field from the database which corresponds to the user name. Dovecot expects it in the user field so we set an alias to <code class=verbatim>user</code>.</li><li><code class=verbatim>userdb_quota_rule</code>: This is the user’s quota in bytes. It is the maximum space on disk that the user can occupy. As documented Dovecot expects the quota in a special format like <code class=verbatim>*:bytes=10000</code> if the user should not be able to store more than 10,000 bytes. That’s why we begin the string with <code class=verbatim>*:bytes=</code>.</li><li><code class=verbatim>userdb_home</code>: This leads to the directory where all emails and various control files for this user are located. The placeholder <code class=verbatim>%d</code> replaces the domain and <code class=verbatim>%n</code> the user part. So for <code class=verbatim>user1</code> that makes it <code class=verbatim>/var/vmail/example.org/user1</code>.</li><li><code class=verbatim>userdb_uid and userdb_gid</code>: Those are the user ID and group ID of vmail user – 5000 for both. Dovecot uses it to set the permissions of files it creates. As all users share the same system user <code class=verbatim>vmail</code> this is just a static number.</li></ul></div></div><div id=outline-container-headline-33 class=outline-3><h3 id=headline-33>Fix Permissions</h3><div id=outline-text-headline-33 class=outline-text-3><p>Make sure that only root can access the SQL configuration file so nobody else is reading your database access passwords:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>sudo chown root:root /etc/dovecot/dovecot-sql.conf.ext
</span></span><span style=display:flex><span>sudo chmod go= /etc/dovecot/dovecot-sql.conf.ext</span></span></code></pre></div></div><p>Restart Dovecot:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl restart dovecot</span></span></code></pre></div></div><p>Look at your /var/log/mail.log logfile. You should see:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Dovecot v2.3.13 (f79e8e7e4) starting up for imap, lmtp, sieve, pop3 (core dumps disabled)</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-34 class=outline-2><h2 id=headline-34>Postfix and Dovecot Communication</h2><div id=outline-text-headline-34 class=outline-text-2><p>In a previous chapters we made sure that Postfix knows which emails it is allowed to receive. Now what to do with the email?</p><p>It has to be saved to disk into the mailbox of the mail user who is waiting for it. You could let Postfix handle that using its built-in mail delivery agent (MDA) called <code class=verbatim>virtual</code>. However compared to the capabilities that Dovecot provides like server-based sieve rules or quotas, the Postfix delivery agent is pretty basic. We are using Dovecot anyway to provide the IMAP (and optionally POP3) service. So let’s use its delivery agent.</p><p>How can we make Postfix hand over the email to Dovecot? There are generally two ways to establish that link.</p><ol><li>Using the <code class=verbatim>dovecot-lda</code> (local delivery agent) process. It can process one email at a time. And it starts up a new process for every email. This was for long the default way. But as you can imagine that it does not scale well.</li><li>The better option is to use <code class=verbatim>LMTP (Local Mail Transport Protocol)</code> that was conceived for this purpose. It can handle multiple recipients at the same time and has a permanently running process which provides a better performance than using the LDA. In short, LMTP is a variant of SMTP with fewer features. It is meant for email communication between internal services that trust each other.</li></ol><p>We are going for the second option. You installed the <code class=verbatim>dovecot-lmtpd</code> package earlier. So let’s configure it.</p><div id=outline-container-headline-35 class=outline-3><h3 id=headline-35>Configure Dovecot to Listen for LMTP Connections from Postfix</h3><div id=outline-text-headline-35 class=outline-text-3><p>Edit Dovecot’s configuration file <code class=verbatim>/etc/dovecot/conf.d/10-master.conf</code> that deals with the LMTP daemon. Look for the <code class=verbatim>service lmtp</code> section and edit it so that it looks like:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>service lmtp {
</span></span><span style=display:flex><span>  unix_listener /var/spool/postfix/private/dovecot-lmtp {
</span></span><span style=display:flex><span>    group = postfix
</span></span><span style=display:flex><span>    mode = 0600
</span></span><span style=display:flex><span>    user = postfix
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>This makes Dovecot’s lmtp daemon create a UNIX socket at <code class=verbatim>/var/spool/postfix/private/dovecot-lmtp</code>. Just like in the section dealing with setting up Dovecot we make it put a socket into the <code class=verbatim>/var/spool/postfix</code> chroot directory because Postfix is restricted to that directory and cannot access anything outside of it. So from Postfix’s point of view the socket is located at <code class=verbatim>/private/dovecot-lmtp</code>.</p><p>Restart Dovecot:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl restart dovecot</span></span></code></pre></div></div></div></div><div id=outline-container-headline-36 class=outline-3><h3 id=headline-36>Configure Postfix to Deliver Mails to Dovecot using LMTP</h3><div id=outline-text-headline-36 class=outline-text-3><p>The <code class=verbatim>virtual_transport</code> in Postfix defines the service to use for delivering emails to the local system. Dovecot has created a socket file and is ready to listen to incoming LMTP connections. We just need to tell Postfix to send emails there:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postconf virtual_transport<span style=color:#f92672>=</span>lmtp:unix:private/dovecot-lmtp</span></span></code></pre></div></div><p>We just told Postfix to use the LMTP protocol. And we want to use a UNIX socket on the same system (instead of a TCP connection). And the socket file is located at <code class=verbatim>/var/spool/postfix/private/dovecot-lmtp</code>.</p></div></div><div id=outline-container-headline-37 class=outline-3><h3 id=headline-37>Enable server-side mail rules&#160;&#160;&#160;<span class=tags><span>ARCHIVE</span></span></h3><div id=outline-text-headline-37 class=outline-text-3><p>One of my favorite features of Dovecot are automatic rules for incoming email that are processed on the server. You can sort away your mailing list emails into special folders. You can reject certain senders. Or you can set up vacation auto-responders. No need to have a mail client running – it all happens automatically on the server even when your mail users are not connected.</p><p>The open-source standard (RFC 5228) for such rules is called Sieve. Basically, Sieve is a way to manage server-side email rules. A rule consists of conditions and actions. For example if the sender address matches <code class=verbatim>user2@example1.com</code> you could tell Dovecot to move such emails to your <code class=verbatim>user2</code> folder automatically. These rules are stored on the Dovecot server and executed automatically. Whether you connect from your smartphone your laptop or use the webmail access – the rules always work and require no configuration on the client side.</p><p>As we use LMTP that’s where we need to tell the lmtp service that we want to use Dovecot’s <code class=verbatim>sieve</code> plugin. Edit the file <code class=verbatim>/etc/dovecot/conf.d/20-lmtp.conf</code> and within the <code class=verbatim>protocol lmtp</code> section change the <code class=verbatim>mail_plugins</code> line to:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>mail_plugins = $mail_plugins sieve</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-38 class=outline-2><h2 id=headline-38>Optional — Quotas</h2><div id=outline-text-headline-38 class=outline-text-2><p>Quotas <sup class=footnote-reference><a id=footnote-reference-2 href=#footnote-2>2</a></sup> are size limits in terms of disk space for users. You can ensure that users do not waste arbitrary amounts of disk space, but are forced to clean up old emails from time to time.</p><p>The magic happens in two places:</p><ol><li>Postfix needs to reject new emails if the user’s mailbox is over quota.</li><li>Dovecot needs to keep track of the quota and how much the user has already used up of it.</li></ol><div id=outline-container-headline-39 class=outline-3><h3 id=headline-39>Enable Quota Plugin</h3><div id=outline-text-headline-39 class=outline-text-3><p>Uncomment or add the following line to <code class=verbatim>/etc/dovecot/conf.d/10-mail.conf</code> file to enable the quota plugin <sup class=footnote-reference><a id=footnote-reference-3 href=#footnote-3>3</a></sup>:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  mail_plugins = quota</span></span></code></pre></div></div></div></div><div id=outline-container-headline-40 class=outline-3><h3 id=headline-40>Quota Policy Service</h3><div id=outline-text-headline-40 class=outline-text-3><p>Let’s start with Dovecot. Edit the file <code class=verbatim>/etc/dovecot/conf.d/90-quota.conf</code>. There are several <code class=verbatim>plugin {…}</code> sections. Take one and make it look like:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>plugin {
</span></span><span style=display:flex><span>  quota = count:User quota
</span></span><span style=display:flex><span>  quota_vsizes = yes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  quota_status_success = DUNNO
</span></span><span style=display:flex><span>  quota_status_nouser = DUNNO
</span></span><span style=display:flex><span>  quota_status_overquota = &#34;452 4.2.2 Mailbox is full and cannot receive any more emails&#34;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>The first line defines that you want to calculate the used space in a user’s maildir. There are several backends but the <code class=verbatim>count</code> <sup class=footnote-reference><a id=footnote-reference-4 href=#footnote-4>4</a></sup> is the best choice in this context. The string <code class=verbatim>User quota</code> is just an arbitrary string that may be queried from a mail user agent.</p><p>The lines starting with <code class=verbatim>quota_status_…</code> set return values for the service that you will set up in a minute. It will tell Postfix that it will not interfere (DUNNO – colloquial way to say "I don’t know"). And it will return a string with a return code <code class=verbatim>452</code> if the user is over quota. Codes starting with <code class=verbatim>4</code> mean temporary errors. It will tell the sending party that it is worth retrying at a later time. However if the user does not resolve the issue it will lead to a bounce error email after three days.</p><p>In the same file (<code class=verbatim>90-quota.conf</code>) add another section:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>service quota-status {
</span></span><span style=display:flex><span>  executable = /usr/lib/dovecot/quota-status -p postfix
</span></span><span style=display:flex><span>  unix_listener /var/spool/postfix/private/quota-status {
</span></span><span style=display:flex><span>    user = postfix
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>This creates a new Dovecot service responding to requests from other processes. You surely recognize that we put it into the jail that Postfix runs in (<code class=verbatim>/var/spool/postfix</code>), so that Postfix can access it.</p><p>Restart Dovecot:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>sudo systemctl restart dovecot</span></span></code></pre></div></div><p>Take a look at the <code class=verbatim>/var/spool/postfix/private</code> directory. If all went as intended you will find a socket file called <code class=verbatim>quota-status</code> there. Otherwise please check the <code class=verbatim>/var/log/mail.log</code> file for errors.</p></div></div><div id=outline-container-headline-41 class=outline-3><h3 id=headline-41>Configure Postfix to Reject When Over Quota</h3><div id=outline-text-headline-41 class=outline-text-3><p>If we stopped here, then Dovecot would reject emails for users who have no space left. However Postfix would still happily receive new emails and attempt to forward them to Dovecot via LMTP. Dovecot however will deny that. It will then keep the email in its queue and retry for a while. In the end it will send a bounce back to the sender telling them about the problem.</p><p>Why is this bad ?</p><ol><li>The sender will assume that the email was delivered while it is stuck in the queue for up to three days.</li><li>Spam emails use forged senders. So at the time that Postfix generates the bounce email it will likely send it to an innocent person. This is called backscatter and considered a mail server misconfiguration. Such a problem may get your mail server blacklisted.</li></ol><p>So the next logical step is to make Postfix check whether a mailbox is over quota whenever a new email arrives. Let’s hook up into the <code class=verbatim>RCPT TO</code> phase of the SMTP dialog when a new email comes in. Postfix checks its <code class=verbatim>smtpd_recipient_restrictions</code> configuration at this stage. Run this command in the shell:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postconf smtpd_recipient_restrictions<span style=color:#f92672>=</span>reject_unauth_destination,<span style=color:#e6db74>&#34;check_policy_service unix:private/quota-status&#34;</span></span></span></code></pre></div></div><p>This adds two checks:</p><ol><li><code class=verbatim>reject_unauth_destination</code> checks whether the mail server is the final destination for the recipient’s email address. This is pretty much the default behavior if you do not define any restrictions.</li><li><code class=verbatim>check_policy_service</code> connects to the socket file at <code class=verbatim>/var/spool/postfix/private/quota-status</code> that was put there by Dovecot. It will use it to ask Dovecot whether the user is over quota in which case the email would get rejected.</li></ol></div></div><div id=outline-container-headline-42 class=outline-3><h3 id=headline-42>Test Quota</h3><div id=outline-text-headline-42 class=outline-text-3><p>Les's set user1’s mailbox quota to 5 KB:</p><div class="src src-sql"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>update</span> virtual_users <span style=color:#66d9ef>set</span> quota<span style=color:#f92672>=</span><span style=color:#ae81ff>4000</span> <span style=color:#66d9ef>where</span> email<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;user1@example1.com&#39;</span>;</span></span></code></pre></div></div><p>Send him a few emails using the <code class=verbatim>swaks</code> tool:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  swaks --server localhost --to user1@example1.com</span></span></code></pre></div></div><p>After a few emails you will see the rejection message:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>-&gt; RCPT TO:user1@example1.com
</span></span><span style=display:flex><span> &lt;** 452 4.2.2 user1@example.org: Recipient address rejected: Mailbox is full and cannot receive any more emails</span></span></code></pre></div></div><p><em>TIPS: If you directly remove files from a user’s Maildir instead of properly accessing the mailbox using IMAP then you will screw up the quota calculation. In that case let Dovecot recalculate the quota — doveadm quota recalc -u user1@example1.com</em></p></div></div><div id=outline-container-headline-43 class=outline-3><h3 id=headline-43>Send Warning Email</h3><div id=outline-text-headline-43 class=outline-text-3><p>The last step is to inform the poor users if they went over quota. So that they do not recognize that on their own. Let’s do that by sending them an email with a warning. We will make sure that the warning email gets through even if the quota is reached.</p><p>Edit the <code class=verbatim>/etc/dovecot/conf.d/90-quota.conf</code> file and add this section to the file:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>plugin {
</span></span><span style=display:flex><span>   quota_warning = storage=95%% quota-warning 95 %u
</span></span><span style=display:flex><span>   quota_warning2 = storage=80%% quota-warning 80 %u
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>service quota-warning {
</span></span><span style=display:flex><span>   executable = script /usr/local/bin/quota-warning.sh
</span></span><span style=display:flex><span>   unix_listener quota-warning {
</span></span><span style=display:flex><span>     user = vmail
</span></span><span style=display:flex><span>     group = vmail
</span></span><span style=display:flex><span>     mode = 0660
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>This section defines two automatic quota warnings. The first (<code class=verbatim>quota_warning</code>) is triggered if the user reaches 95% of the quota. The second (<code class=verbatim>quota_warning2</code>) at 80%. These lines follow this schema:</p><ul><li>Trigger (e.g. <code class=verbatim>storage=95%</code>). The <code class=verbatim>%</code> sign needs to be used twice if you want to emit a literal percent sign. So this is not a typo.</li><li>The socket you want to call in that case. Our socket is the <code class=verbatim>service quota-warning</code> that calls a shell script.</li><li>Additional parameters that are passed to the shell script in our case. They tell the script the percentage that has been reached (e.g. <code class=verbatim>95</code>) and the address of the user who should get the warning.</li></ul><p>No we create a script file at <code class=verbatim>/usr/local/bin/quota-warning.sh</code>:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  <span style=color:#75715e>#!/bin/sh</span>
</span></span><span style=display:flex><span>  PERCENT<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>  USER<span style=color:#f92672>=</span>$2
</span></span><span style=display:flex><span>  cat <span style=color:#e6db74>&lt;&lt; EOF | /usr/lib/dovecot/dovecot-lda -d $USER -o &#34;plugin/quota=maildir:User quota:noenforcing&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  From: postmaster@webmail.example.org
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  Subject: Quota warning - $PERCENT% reached
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  Your mailbox can only store a limited amount of emails.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  Currently it is $PERCENT% full. If you reach 100% then
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  new emails cannot be stored. Thanks for your understanding.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  EOF</span></span></span></code></pre></div></div><p>Make this file executable:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo chmod +x /usr/local/bin/quota-warning.sh</span></span></code></pre></div></div><p>Restart Dovecot:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>sudo systemctl restart dovecot</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-44 class=outline-2><h2 id=headline-44>Test IMAP</h2><div id=outline-text-headline-44 class=outline-text-2><p>Send a test mail to the user:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  swaks --to user1@example1.com --server localhost</span></span></code></pre></div></div><p>Then use <code class=verbatim>mutt</code> to read the mail on the IMAP server:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  mutt -f imaps://user1@example1.com@example1.com</span></span></code></pre></div></div></div></div><div id=outline-container-headline-45 class=outline-2><h2 id=headline-45>SMTP Authentication</h2><div id=outline-text-headline-45 class=outline-text-2><div id=outline-container-headline-46 class=outline-3><h3 id=headline-46>Postfix Delegates Authentication to Dovecot</h3><div id=outline-text-headline-46 class=outline-text-3><p>We have already configured Dovecot to know everything about users from the SQL database. So let's tell Postfix to use the Dovecot server as an authentication server to verify the username and password. Run these commands on the shell:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postconf smtpd_sasl_type<span style=color:#f92672>=</span>dovecot
</span></span><span style=display:flex><span>  sudo postconf smtpd_sasl_path<span style=color:#f92672>=</span>private/auth
</span></span><span style=display:flex><span>  sudo postconf smtpd_sasl_auth_enable<span style=color:#f92672>=</span>yes</span></span></code></pre></div></div><p>Postfix can send authentication request to Dovecot through a socket file located at chroot directory — <code class=verbatim>/var/spool/postfix/private/auth</code>. (Postfix cannot access any file outside <code class=verbatim>/var/spool/postfix</code> directory.</p><p>In a previous section we edited the <code class=verbatim>/etc/dovecot/conf.d/10-master.conf</code> file and made Dovecot place a socket file into <code class=verbatim>/var/spool/postfix/private/auth</code> to allow communication from Postfix.</p><p>The following settings enable encryption, set the key and certificate paths for Postfix:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postconf smtpd_tls_security_level<span style=color:#f92672>=</span>may
</span></span><span style=display:flex><span>  sudo postconf smtpd_tls_auth_only<span style=color:#f92672>=</span>yes
</span></span><span style=display:flex><span>  sudo postconf smtpd_tls_cert_file<span style=color:#f92672>=</span>/etc/letsencrypt/live/example1.com/fullchain.pem
</span></span><span style=display:flex><span>  sudo postconf smtpd_tls_key_file<span style=color:#f92672>=</span>/etc/letsencrypt/live/example1.com/privkey.pem
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  sudo postconf smtp_tls_security_level<span style=color:#f92672>=</span>may</span></span></code></pre></div></div><p><em>NOTE: Here we have two types of configuration directives, one starting with <code class=verbatim>smtp_</code> and the second with <code class=verbatim>smtpd_</code>. The <code class=verbatim>smtp_</code> refers to the SMTP client (do not confuse with MUA such as Thunderbird, mutt, etc), the component that sends mail from Postfix to other SMTP servers. <code class=verbatim>smtpd_</code> refers to the SMTP server. This is the component that receives mail from other systems, either from other SMTP server or from one of your SMTP users.</em></p><p>The above settings allow encrypted incoming (<code class=verbatim>smtpd_</code>) and outgoing (<code class=verbatim>smtp_</code>) connections. But they do not enforce it. So if a remote mail server does not have encryption enabled, we will still accept its emails, otherwise the emails will be rejected.</p><p>However the <code class=verbatim>smtpd_tls_auth_only=yes</code> setting makes sure that the user’s authentication information (email address and password) are always encrypted between the user and your mail server.</p></div></div><div id=outline-container-headline-47 class=outline-3><h3 id=headline-47>How SMTP Authentication Works ?</h3></div><div id=outline-container-headline-48 class=outline-3><h3 id=headline-48>Unencrypted SMTP Communication</h3><div id=outline-text-headline-48 class=outline-text-3><p>Let's connect to TCP port 25 on localhost using Telnet:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  telnet localhost <span style=color:#ae81ff>25</span></span></span></code></pre></div></div><p>The server will let you in:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Trying 127.0.0.1…
</span></span><span style=display:flex><span>Connected to localhost.
</span></span><span style=display:flex><span>Escape character is &#39;^]&#39;.
</span></span><span style=display:flex><span>220 webmail ESMTP Postfix (Debian/GNU)</span></span></code></pre></div></div><p>Start the communication by introducing yourself to the SMTP server or in other words specifying the domain name or IP address of the SMTP client:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ehlo example.com</span></span></code></pre></div></div><p>Postfix will present a list of features that are available for you:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>250-mailtest
</span></span><span style=display:flex><span>250-PIPELINING
</span></span><span style=display:flex><span>250-SIZE 10240000
</span></span><span style=display:flex><span>250-VRFY
</span></span><span style=display:flex><span>250-ETRN
</span></span><span style=display:flex><span>250-STARTTLS
</span></span><span style=display:flex><span>250-ENHANCEDSTATUSCODES
</span></span><span style=display:flex><span>250-8BITMIME
</span></span><span style=display:flex><span>250-DSN
</span></span><span style=display:flex><span>250-SMTPUTF8
</span></span><span style=display:flex><span>250 CHUNKING</span></span></code></pre></div></div><ul><li><code class=verbatim>PIPELINING</code>
This is a feature to speed up SMTP communication. Usually the remote system (who initiate a SMTP connection) has to wait for a response to every command it sends. Pipelining allows the remote server to send several commands in a batch without waiting for a response.
Our Postfix will just store these commands and execute them one by one. If you told Postfix to forbid pipelining it would disconnect the remote server when it tries to send bulks of commands without waiting for the proper reply. It is mainly a feature against rogue senders.</li><li><code class=verbatim>SIZE 10240000</code>
The remote server is allowed to send emails up to 10 MB large. This has long been a common maximum size for emails. However nowadays 40 MB or even more are more common sizes because emails have grown larger. Some mail servers even allow 100 MB.</li><li><code class=verbatim>VRFY</code>
Allows remote servers to verify a given name or email address. For example the remote server could send <code class=verbatim>VRFY user1</code> and your server might respond <code class=verbatim>250 User1 &lt;user1@example1.com></code>. It can be used to verify that a certain recipient email address is deliverable</li><li><code class=verbatim>ETRN</code>
A command that a remote system can send to flush the Postfix queue of mails for a certain domain. It can be used if the remote system had technical problems and failed to receive email for a while. Then it could send an ETRN command to make your server start sending outstanding emails for that domain. It is rarely used.</li><li><code class=verbatim>STARTTLS</code>
This tells the remote system that it might start switching from this unencrypted to an encrypted connection by sending the <code class=verbatim>STARTTLS</code> command. It will then start negotiating a TLS-encrypted connection.
You could compare it to an HTTP connection that suddenly switches over to an encrypted HTTPS connection. The advantage is that you can start talking SMTP on TCP port 25 and don’t have to open up a second TCP port like 465 which is the "SSMTP" (secure SMTP) port and which only accepts encrypted connections.</li><li><code class=verbatim>ENHANCEDSTATUSCODES</code></li></ul><p>This enables more three-digit return codes for various conditions. See the RFC2034 <sup class=footnote-reference><a id=footnote-reference-5 href=#footnote-5>5</a></sup> for more details.</p><ul><li><code class=verbatim>8BITMIME</code>
In ancient times SMTP only processed 7-bit characters. You couldn’t transfer special characters like <code class=verbatim>Ä</code> or <code class=verbatim>ß</code> without special encoding. The <code class=verbatim>8BITMIME</code> allows a transmission of emails using 8-bit characters. Still many emails are specially encoded using ISO8859-1 or UTF-8.</li><li><code class=verbatim>DSN</code>
It enables DSNs (delivery status notofications) that allows the sender to control the messages that Postfix creates when an email could not be delivered as intended.</li><li><code class=verbatim>SMTPUTF8</code>
In addition to <code class=verbatim>8BITMIME</code> you can use UTF8 encoded characters in header fields.</li><li><code class=verbatim>CHUNKING</code>
This feature (described in RFC 3030) makes sending of large emails more efficient.</li></ul><p>However one important line is missing here that would allow us to send our username and password:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>250-AUTH PLAIN LOGIN</span></span></code></pre></div></div><p>We told Postfix to only allow authentication when the connection is encrypted. So we are not offered authentication over this plain text connection. So we need an encrypted connection using TLS. Using the <code class=verbatim>STARTTLS</code> feature we can switch over from unencrypted to encrypted without having to reconnect. So enter:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>STARTTLS</span></span></code></pre></div></div><p>And the server replies:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>220 2.0.0 Ready to start TLS</span></span></code></pre></div></div><p>However now it’s getting weird because you would have to speak TLS encryption which is not a language that humans speak. So let’s quit this using the <code>QUIT</code> command and do that differently.</p></div></div><div id=outline-container-headline-49 class=outline-3><h3 id=headline-49>Ecrypted SMTP Communication</h3><div id=outline-text-headline-49 class=outline-text-3><p>So we use OpenSSL to help us with the ecryption:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>openssl s_client -connect localhost:25 -starttls smtp</span></span></code></pre></div></div><p>You will see a lot of output. OpenSSL has connected to TCP port 25 and issued a STARTTLS command to switch to an encrypted connection. So whatever you type now will get encrypted. Enter:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>EHLO example.com</span></span></code></pre></div></div><p>And Postfix will send a list of capabilities that will look like this:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>250-PIPELINING
</span></span><span style=display:flex><span>250-SIZE 10240000
</span></span><span style=display:flex><span>250-VRFY
</span></span><span style=display:flex><span>250-ETRN
</span></span><span style=display:flex><span>250-AUTH PLAIN LOGIN
</span></span><span style=display:flex><span>250-ENHANCEDSTATUSCODES
</span></span><span style=display:flex><span>250-8BITMIME
</span></span><span style=display:flex><span>250 DSN</span></span></code></pre></div></div><p>And now that we are using an encrypted connection Postfix offers us to authenticate. So let us send the authentication string with a Base64-encoded password:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>AUTH PLAIN AGpvaG5AZXhhbXBsZS5vcmcAc3VtbWVyc3Vu</span></span></code></pre></div></div><ul><li><p>We use an encoded string because, in general, SMTP can only transfer ASCII characters. But the email address may contain special characters that are not covered by ASCII. So, in the PLAIN method, we encode the foloowing information in Base64 — <code class=verbatim>NULL-BYTE + USERNAME + NULL-BYTE + PASSWORD</code>.</p><p>So for user1’s case you can easily create the Base64 string using:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  printf <span style=color:#e6db74>&#39;\0user1@example1.com\0SecurePass&#39;</span> | base64</span></span></code></pre></div></div></li></ul><p>Unless you have changed user1's password to something else than <code class=verbatim>SecurePass</code> the server should accept that authentication:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>235 2.7.0 Authentication successful</span></span></code></pre></div></div><p>Excellent. You are logged in through SMTP. You could now send an email to be forwarded to another mail server. Here I just wanted to show that authentication works if you use an encrypted connection.</p><p>Disconnect from Postfix:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>QUIT</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-50 class=outline-2><h2 id=headline-50>Postfix Submission Service</h2><div id=outline-text-headline-50 class=outline-text-2><p>End users should not use port 25 but rather the submission service on TCP port 587 (as described in RFC 4409). The idea is to use port 25 to transport emails through the Mail Transport Agent (MTA) from one server to server and port 587 to submit emails through the Mail Submission Agent (MSA) from a user to a mail server.</p><p>In order to enable the submission port, we need to edit the file <code class=verbatim>/etc/postfix/master.cf</code> where all Postfix services are declared. Edit this file and find the submission section which is commented out by default. Transform this section into the following. Basically, I removed the <code class=verbatim>#</code> character on all lines in this section and removed the lines with the <code class=verbatim>mua_*</code> variables:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>submission inet n       -       y       -       -       smtpd
</span></span><span style=display:flex><span>  -o syslog_name=postfix/submission
</span></span><span style=display:flex><span>  -o smtpd_tls_security_level=encrypt
</span></span><span style=display:flex><span>  -o smtpd_sasl_auth_enable=yes
</span></span><span style=display:flex><span>  -o smtpd_tls_auth_only=yes
</span></span><span style=display:flex><span>  -o smtpd_reject_unlisted_recipient=no
</span></span><span style=display:flex><span>  -o smtpd_client_restrictions=
</span></span><span style=display:flex><span>  -o smtpd_helo_restrictions=
</span></span><span style=display:flex><span>  -o smtpd_sender_restrictions=
</span></span><span style=display:flex><span>  -o smtpd_relay_restrictions=
</span></span><span style=display:flex><span>  -o smtpd_recipient_restrictions=permit_sasl_authenticated,reject
</span></span><span style=display:flex><span>  -o milter_macro_daemon_name=ORIGINATING</span></span></code></pre></div></div><p><strong>CAREFUL: Make sure to start the first line in the first column and indent the following lines.</strong></p><ul><li><code class=verbatim>smtpd</code>: This service uses the <a href="Postfix SMTP Client and Server">smtpd daemon</a> which is the piece of software that responds if you open an SMTP connection on TCP port 25.</li><li><code class=verbatim>syslog_name</code>: In the /var/log/mail.log log file you will see the connections to the submission port as postfix/submission.</li><li><code class=verbatim>smtpd_tls_security_level</code>: Enforce encryption on port 587.</li><li><code class=verbatim>smtpd_sasl_auth_enable</code>: Enable authentication.</li><li><code class=verbatim>smtpd_tls_auth_only</code> Enforce encryption during authentication.</li><li><code class=verbatim>smtpd_reject_unlisted_recipient</code>: Allow sending emails to recipients outside of this mail server.</li><li><code class=verbatim>smtpd_*_restrictions</code>: Remove special restrictions.</li><li><code class=verbatim>smtpd_recipient_restrictions</code>: allow relaying if the sender was authenticated.</li><li><code class=verbatim>milter_macro_daemon_name</code>: Assigns a macro value (in this case, <code class=verbatim>ORIGINATING</code>) that can be passed to Milter applications (e.g., for spam and virus filtering) to indicate the specific context or phase of email handling. Setting this to <code class=verbatim>ORIGINATING</code> identifies the email as coming from a sender inside your network, typically an authenticated or authorized sender. This is often done to inform Milter applications that the email originates from a trusted internal source. It can help these filters apply specific rules or bypass some checks for outgoing mail, such as spam filtering, which might not be necessary for internal users.</li></ul><p>Restart the Postfix server:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  systemctl restart postfix</span></span></code></pre></div></div><div id=outline-container-headline-51 class=outline-3><h3 id=headline-51>Test Submission Service</h3><div id=outline-text-headline-51 class=outline-text-3><p>Your users can now use the submission port to send email. They just use the port 587 in their mail clients instead of port 25. You will need to install the <code class=verbatim>libnet-ssleay-perl</code> package first to use TLS encryption in SWAKS:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo apt install -y libnet-ssleay-perl</span></span></code></pre></div></div><p>Send a mails on submission port 587:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  swaks --server localhost --to user1@example1.com --port <span style=color:#ae81ff>587</span> -tls --auth-user user1@example1.com --auth-password SecurePass</span></span></code></pre></div></div><p><em>NOTE: What is Port 465 ? This TCP port belongs to the "submission over TLS" service. It is used for the submission service but expects an encrypted connection from the first byte. This port is hardly ever used so you don’t have to care about it. The submission service you just configured is also encrypted but uses the STARTTLS mechanism to switch to a TLS connection after the welcome message.</em></p></div></div></div></div><div id=outline-container-headline-52 class=outline-2><h2 id=headline-52>Deny Forged Sender Addresses</h2><div id=outline-text-headline-52 class=outline-text-2><p>A forged sender address means that someone claims to be someone else. Let’s say that <code class=verbatim>user1</code> has authenticated and the mail server trusts him. Nothing keeps <code class=verbatim>user1</code> from impersonating someone else and sending email in his name.</p><p>Postfix provides a setting called <code class=verbatim>smtpd_sender_login_maps</code> to prevent the problem:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postconf smtpd_sender_login_maps<span style=color:#f92672>=</span>mysql:/etc/postfix/mysql-email2email.cf</span></span></code></pre></div></div><p>Now create a map file at <code class=verbatim>/etc/postfix/mysql-email2email.cf</code> that Postfix use to search for user's mail address:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>user = mailserver
</span></span><span style=display:flex><span>password = x893dNj4stkHy1MKQq0USWBaX4ZZdq
</span></span><span style=display:flex><span>hosts = 127.0.0.1
</span></span><span style=display:flex><span>dbname = mailserver
</span></span><span style=display:flex><span>query = SELECT email FROM virtual_users WHERE email=&#39;%s&#39;</span></span></code></pre></div></div><p>This sets the parameter both for the SMTP port (25) and the submission port (587). Defining these maps is not enough though. You also need to make Postfix act on this. Edit the <code class=verbatim>/etc/postfix/master.cf</code> again and in the submission section add the following option. Make sure the line is indented like all other options:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> -o smtpd_sender_restrictions=reject_sender_login_mismatch,permit_sasl_authenticated,reject</span></span></code></pre></div></div><p>Restart Postfix:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>systemctl restart postfix</span></span></code></pre></div></div><p>You can now try to send email as a different user than you are logged in. Let’s us swaks again to send a spoofed email:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  swaks --server localhost --from user2@example1.com --to user3example1.com --port <span style=color:#ae81ff>587</span> -tls --auth-user user1@example1.com --auth-password SecurePass</span></span></code></pre></div></div><p>You will get the following error message:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>~&gt; MAIL FROM:user2@example1.com
</span></span><span style=display:flex><span>&lt;~ <span style=color:#ae81ff>250</span> 2.1.0 Ok
</span></span><span style=display:flex><span>~&gt; RCPT TO:user3@example.com
</span></span><span style=display:flex><span>&lt;~* <span style=color:#ae81ff>553</span> 5.7.1 user2@example1.com: Sender address rejected: not owned by user user1@example1.com</span></span></code></pre></div></div></div></div><div id=outline-container-headline-53 class=outline-2><h2 id=headline-53>Sender Policy Framework (SPF)</h2><div id=outline-text-headline-53 class=outline-text-2><p>A Sender Policy Framework (SPF) is a method to verify that the mail server sending the email is authorized to send mail on behalf of the domain.</p><p>The receiving SMTP mail server queries the DNS server of the domain found in the header of the received email — <code class=verbatim>Return-Path</code>, for a TXT record. This record contains the IP addresses of the authorized mail servers defined by the domain owner to send mail on behalf of the domain in question.</p><p>This record also indicates the receiving SMTP server to allow, reject or mark as spam if the SPF check fails, in other words if the IP address of the sending SMTP server does not match the IP address retrieved from the TXT record.</p><div id=outline-container-headline-54 class=outline-3><h3 id=headline-54>Create an SPF Record in DNS</h3><div id=outline-text-headline-54 class=outline-text-3><p>Let's create a new TXT record in DNS to tell the receiving SMTP server which IP addresses are allowed to send mail for your domain:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  TXT  @   v=spf1 mx ~all</span></span></code></pre></div></div><ul><li><code class=verbatim>TXT</code>: Indicates this is a TXT record.</li><li><code class=verbatim>@</code>: Represents the domain.</li><li><code class=verbatim>v=spf1</code> Indicates an SPF record and the SPF record version is SPF1.</li><li><code class=verbatim>mx</code>: Allow all hosts listed in the MX records to send emails for your domain and all other hosts are disallowed.</li><li><code class=verbatim>~all</code>: Indicates that emails from your domain should only come from hosts specified in the SPF record. Emails that are from other hosts will be flagged as untrustworthy. Possible alternatives are <code class=verbatim>+all</code>, <code class=verbatim>-all</code>, <code class=verbatim>?all</code>.(E.g: <code class=verbatim>-all</code> means emails sent from not-allowed hosts should be rejected, never to land in the recipient’s inbox or spam folder)</li></ul><p>To check if your SPF record is propagated on the Internet, query a DNS server for your domain's TXT record:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  dig your-domain.com txt</span></span></code></pre></div></div></div></div><div id=outline-container-headline-55 class=outline-3><h3 id=headline-55>SPF Check for Incoming Emails</h3><div id=outline-text-headline-55 class=outline-text-3><p>We have created a TXT record in DNS to inform the other SMTP server that receiving emails our authorized SMTP servers. Now we need to tell our Postfix server to do this check before accepting mail.</p><p>Install required SPF package:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo apt install postfix-policyd-spf-python</span></span></code></pre></div></div><p>Then edit the Postfix master process configuration file:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>sudo nano /etc/postfix/master.cf</span></span></code></pre></div></div><p>Add the following lines at the end of the file, which tells Postfix to start the SPF policy daemon when it’s starting itself:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>policyd-spf  unix  -       n       n       -       0       spawn
</span></span><span style=display:flex><span>    user=policyd-spf argv=/usr/bin/policyd-spf</span></span></code></pre></div></div><p>Save and close the file. Next, edit Postfix main configuration file.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/postfix/main.cf</span></span></code></pre></div></div><p>Append the following lines at the end of the file. The first line specifies the Postfix policy agent timeout setting. The following lines will impose a restriction on incoming emails by checking SPF record.</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>policyd-spf_time_limit = 3600
</span></span><span style=display:flex><span>smtpd_recipient_restrictions =
</span></span><span style=display:flex><span>   reject_unauth_destination,
</span></span><span style=display:flex><span>   check_policy_service unix:private/quota-status,
</span></span><span style=display:flex><span>   check_policy_service unix:private/policyd-spf</span></span></code></pre></div></div><p>Save and close the file. Then restart Postfix.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl restart postfix</span></span></code></pre></div></div><p>Next time, when you receive an email from a domain that has an SPF record, you can see the SPF check results in the raw email header. The following header indicates the sender sent the email from an authorized host.</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Received-SPF: Pass (sender SPF authorized).</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-56 class=outline-2><h2 id=headline-56>DomainKeys Identified Mail (DKIM)</h2><div id=outline-text-headline-56 class=outline-text-2><p>Email sender spoofing involves pretending to control another person's email address. Scammers often send emails with a sender address like <code class=verbatim>someone@paypal.com</code> and hope that the recipient will fall for it and trust them. In fact, SMTP doesn't care what sender address you send from. Many email service providers require you to send emails only with your own email address. But some don't.</p><p>To avoid this problem, a new method was conceived that add a cryptographic signature to the header of an email, which the recipient can check to verify the authenticity of the sender and the integrity of the email.</p><p>The signature is created using a private key that only the sending mail server has. It can then be verified by the recipient by downloading the corresponding public key from the DNS zone of the sending domain and running a signature check. This works very similarly to PGP or S/MIME signing, but at the domain level. Also your mail server automatically sign all outgoing emails.</p><div id=outline-container-headline-57 class=outline-3><h3 id=headline-57>Configure DKIM</h3><div id=outline-text-headline-57 class=outline-text-3><p>First, install OpenDKIM which is an open-source implementation of the DKIM sender authentication system:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo apt install opendkim opendkim-tools</span></span></code></pre></div></div><p>Then add postfix user to opendkim group.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo gpasswd -a postfix opendkim</span></span></code></pre></div></div><p>Edit OpenDKIM main configuration file.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/opendkim.conf</span></span></code></pre></div></div><p>By default, OpenDKIM logs will be saved in <code class=verbatim>/var/log/mail.log</code> file. Add the following line so OpenDKIM will generate more detailed logs for debugging:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Syslog               yes
</span></span><span style=display:flex><span>Logwhy               yes</span></span></code></pre></div></div><p>Then, find the following lines. Uncomment them and replace <code class=verbatim>simple</code> with <code class=verbatim>relaxed/simple</code>:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>#Canonicalization   simple
</span></span><span style=display:flex><span>#Mode               sv
</span></span><span style=display:flex><span>#SubDomains         no</span></span></code></pre></div></div><p>Then add the following lines below <code class=verbatim>#ADSPAction continue</code> line. If your file doesn’t have <code class=verbatim>#ADSPAction continue</code> line, then just add them below <code class=verbatim>SubDomains no</code>:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>AutoRestart         yes
</span></span><span style=display:flex><span>AutoRestartRate     10/1M
</span></span><span style=display:flex><span>Background          yes
</span></span><span style=display:flex><span>DNSTimeout          5
</span></span><span style=display:flex><span>SignatureAlgorithm  rsa-sha256</span></span></code></pre></div></div><p>Next, add the following lines at the end of this file:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>#OpenDKIM user
</span></span><span style=display:flex><span># Remember to add user postfix to group opendkim
</span></span><span style=display:flex><span>UserID             opendkim
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Map domains in From addresses to keys used to sign messages
</span></span><span style=display:flex><span>KeyTable           refile:/etc/opendkim/key.table
</span></span><span style=display:flex><span>SigningTable       refile:/etc/opendkim/signing.table
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Hosts to ignore when verifying signatures
</span></span><span style=display:flex><span>ExternalIgnoreList  /etc/opendkim/trusted.hosts
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># A set of internal hosts whose mail should be signed
</span></span><span style=display:flex><span>InternalHosts       /etc/opendkim/trusted.hosts</span></span></code></pre></div></div></div></div><div id=outline-container-headline-58 class=outline-3><h3 id=headline-58>Create Signing Table, Key Table and Trusted Hosts File</h3><div id=outline-text-headline-58 class=outline-text-3><p>Create a directory structure for OpenDKIM:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo mkdir /etc/opendkim
</span></span><span style=display:flex><span>  sudo mkdir /etc/opendkim/keys</span></span></code></pre></div></div><p>Change the owner from root to opendkim and make sure only opendkim user can read and write to the keys directory:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo chown -R opendkim:opendkim /etc/opendkim
</span></span><span style=display:flex><span>  sudo chmod go-rw /etc/opendkim/keys</span></span></code></pre></div></div><p>Create the signing table:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/opendkim/signing.table</span></span></code></pre></div></div><p>Add the following two lines to the file. This tells OpenDKIM that if a sender on your server is using a <code class=verbatim>@example.com</code> address, then it should be signed with the private key identified by <code class=verbatim>default._domainkey.example1.com</code>. The second line tells that your sub-domains will be signed by the private key as well.</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>*@example.com    default._domainkey.example.com
</span></span><span style=display:flex><span>*@*.example.com    default._domainkey.example.com</span></span></code></pre></div></div><p>Then create the key table:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/opendkim/key.table</span></span></code></pre></div></div><p>Add the following line, which tells the location of the private key:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>default._domainkey.example1.com     example1.com:default:/etc/opendkim/keys/example1.com/default.private</span></span></code></pre></div></div><p>Next, create the trusted hosts file:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/opendkim/trusted.hosts</span></span></code></pre></div></div><p>Add the following lines to the newly created file. This tells OpenDKIM that if an email is coming from localhost or from the same domain, then OpenDKIM should only sign the email but not perform DKIM verification on the email:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>127.0.0.1
</span></span><span style=display:flex><span>localhost
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.example1.com</span></span></code></pre></div></div><p><strong>CAREFUL: You should not add an asterisk in the domain name like this: =</strong>.example1.com=. There should be only a dot before the domain name.*</p></div></div><div id=outline-container-headline-59 class=outline-3><h3 id=headline-59>Generate Private/Public Keypair</h3><div id=outline-text-headline-59 class=outline-text-3><p>Since DKIM is used to sign outgoing messages and verify incoming messages, we need to generate a private key for signing and a public key for remote verifier. Public key will be published in DNS.</p><p>Create a separate folder for the domain:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo mkdir /etc/opendkim/keys/example1.com</span></span></code></pre></div></div><p>Generate keys using the <code>opendkim-genkey</code> tool, this will store the private key in a <code class=verbatim>default.private</code> file and the public key in the <code class=verbatim>default.txt</code> file:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo opendkim-genkey -b <span style=color:#ae81ff>2048</span> -d example1.com -D /etc/opendkim/keys/example1.com -s default -v</span></span></code></pre></div></div><ul><li><code class=verbatim>-b</code>: Create 2048 bits keys.</li><li><code class=verbatim>-d</code>; Specifies the domain.</li><li><code class=verbatim>-D</code>: Specifies the directory where the keys will be stored.</li><li><code class=verbatim>-s</code>: Name of the selector.</li></ul><p>Make opendkim as the owner of the private key:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo chown opendkim:opendkim /etc/opendkim/keys/your-domain.com/default.private</span></span></code></pre></div></div><p>And change the permission, so only the opendkim user has read and write access to the file:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo chmod <span style=color:#ae81ff>600</span> /etc/opendkim/keys/your-domain.com/default.private</span></span></code></pre></div></div></div></div><div id=outline-container-headline-60 class=outline-3><h3 id=headline-60>Publish Your Public Key in DNS Record</h3><div id=outline-text-headline-60 class=outline-text-3><p>Display the public key:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo cat /etc/opendkim/keys/example1.com/default.txt</span></span></code></pre></div></div><p>In your DNS, create a TXT record and enter <code class=verbatim>default._domainkey</code> in the name field. Then copy everything between the parentheses and paste it into the value field of the DNS record. You need to delete all double quotes and white spaces in the value field. If you don’t delete them, then the key test in the next step will probably fail.</p></div></div><div id=outline-container-headline-61 class=outline-3><h3 id=headline-61>Test DKIM Key</h3><div id=outline-text-headline-61 class=outline-text-3><p>Enter the following command on Ubuntu server to test your key.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo opendkim-testkey -d example1.com -s default -vvv</span></span></code></pre></div></div><p>If everything is OK, you will see Key OK in the command output:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>opendkim-testkey: using default configfile /etc/opendkim.conf
</span></span><span style=display:flex><span>opendkim-testkey: checking key &#39;default._domainkey.example.com&#39;
</span></span><span style=display:flex><span>opendkim-testkey: key secure
</span></span><span style=display:flex><span>opendkim-testkey: key OK</span></span></code></pre></div></div><p>Your DKIM record may need sometime to propagate to the Internet. Depending on the domain registrar you use, your DNS record might be propagated instantly, or it might take up to 24 hours to propagate. You can also test on some online <sup class=footnote-reference><a id=footnote-reference-6 href=#footnote-6>6</a></sup> sites to check if the DKIM record is propagated by entering the selector name (in our case <code class=verbatim>default</code>).</p><p>If you see <code class=verbatim>Key not secure</code> in the command output, this is because DNSSEC isn’t enabled on your domain name. DNSSEC is a security standard for secure DNS query. Most domain names haven’t enabled DNSSEC.</p><p>If you see the query timed out error, you need to comment out the following line in <code class=verbatim>/etc/opendkim.conf</code> file and restart <code class=verbatim>opendkim.service</code>:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>TrustAnchorFile       /usr/share/dns/root.key</span></span></code></pre></div></div></div></div><div id=outline-container-headline-62 class=outline-3><h3 id=headline-62>Connect Postfix to OpenDKIM</h3><div id=outline-text-headline-62 class=outline-text-3><p>Postfix can talk to OpenDKIM via a Unix socket file. The default socket file used by OpenDKIM is <code class=verbatim>/var/run/opendkim/opendkim.sock</code>, as shown in <code class=verbatim>/etc/opendkim.conf</code> file. But the postfix SMTP daemon runs in a chroot jail, which means the SMTP daemon resolves all filenames relative to the Postfix directory (<code class=verbatim>/var/spool/postfix</code>). So we need to change the OpenDKIM Unix socket file.</p><p>Create a directory to hold the OpenDKIM socket file and allow only opendkim user and postfix group to access it:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo mkdir /var/spool/postfix/opendkim
</span></span><span style=display:flex><span>  sudo chown opendkim:postfix /var/spool/postfix/opendkim</span></span></code></pre></div></div><p>Then edit the OpenDKIM main configuration file:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/opendkim.conf</span></span></code></pre></div></div><p>And replace the <code class=verbatim>Socket local:/run/opendkim/opendkim.sock</code> with (or add) the following line:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Socket    local:/var/spool/postfix/opendkim/opendkim.sock</span></span></code></pre></div></div><p>If you can find any of the following line</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>SOCKET=&#34;local:/var/run/opendkim/opendkim.sock&#34;
</span></span><span style=display:flex><span>SOCKET=local:$RUNDIR/opendkim.sock</span></span></code></pre></div></div><p>Change it to:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>SOCKET=&#34;local:/var/spool/postfix/opendkim/opendkim.sock&#34;</span></span></code></pre></div></div><p>Now we need to edit the Postfix main configuration file:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/postfix/main.cf</span></span></code></pre></div></div><p>Add the following lines at the end of this file, so Postfix can call OpenDKIM via the milter protocol:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># Milter configuration
</span></span><span style=display:flex><span>milter_default_action = accept
</span></span><span style=display:flex><span>milter_protocol = 6
</span></span><span style=display:flex><span>smtpd_milters = local:opendkim/opendkim.sock
</span></span><span style=display:flex><span>non_smtpd_milters = $smtpd_milters</span></span></code></pre></div></div><p>Finally restart opendkim and postfix service:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl restart opendkim postfix</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-63 class=outline-2><h2 id=headline-63>DMARC</h2><div id=outline-text-headline-63 class=outline-text-2><p>DMARC stands for Domain-based message authentication, reporting and conformance. DMARC is not a product but it is a freely available technical specification. DMARC tells the recipeient's SMTP server to allow, reject or quarantine when SPF and DKIM verification is not valid.</p><div id=outline-container-headline-64 class=outline-3><h3 id=headline-64>Create DMARC Record</h3><div id=outline-text-headline-64 class=outline-text-3><p>Go to your DNS manager and add a TXT record. In the name field, enter <code class=verbatim>_dmarc</code>. In the value field, enter the following:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v=DMARC1; p=none; pct=100; rua=mailto:dmarc-reports@example1.com</span></span></code></pre></div></div><ul><li><code class=verbatim>v=DMARC1</code>: The protocol version is DMARC1.</li><li><code class=verbatim>p=none</code>: We choose none as the <code class=verbatim>policy</code> for our domain.</li><li><code class=verbatim>pct=100</code>: The percentage of emails from your domain DMARC applies to.</li><li><code class=verbatim>rua</code> Stands for reporting URI for aggregate report. The email address is used to tell receiving email servers where report should be sent.</li></ul><p><strong>CAREFUL: Replace dmarc-reports@example1.com with your real email address that is used to receive aggregate DMARC report.</strong></p><p>There are 3 policies you can choose from:</p><ul><li><code class=verbatim>none</code>: Tells receiving email servers not to do anything special if DMARC check fails.</li><li><code class=verbatim>quarantine</code>: Tells receiving email server to put the email into quarantine if DMARC check fails. It must be approved by an admin before it can reach the recipient’s inbox.</li><li><code class=verbatim>reject</code>: Tells receiving email servers to reject the email if DMARC check fails.</li></ul><p>There’s another tag that you can add to the DMARC record: <code class=verbatim>fo</code>. It has four possible values:</p><ul><li><code class=verbatim>0</code> (default): Generate reports if <strong>all</strong> underlying authentication mechanisms fail to produce a DMARC pass result.</li><li><code class=verbatim>1</code>: Generate reports if <strong>any</strong> mechanisms fail.</li><li><code class=verbatim>d</code>: Generate a report if DKIM signature failed verification.</li><li><code class=verbatim>s</code>: Generate a report if SPF failed.</li></ul><p>For example, you can set <code class=verbatim>fo:1</code> to receive a report if any mechanism fails:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v=DMARC1; p=none; pct=100; fo=1; rua=mailto:dmarck-reports@example1.com</span></span></code></pre></div></div><p>Once the DMARC record is added, test it by querying the DNS server:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  dig txt +short _dmarc.example1.com</span></span></code></pre></div></div><p>Or by using the <code class=verbatim>opendmarc</code> utility which will produce formatted text:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  opendmarc-check example1.com</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-65 class=outline-2><h2 id=headline-65>SPF and DKIM Check</h2><div id=outline-text-headline-65 class=outline-text-2><div id=outline-container-headline-66 class=outline-3><h3 id=headline-66>Send A Email to Gmail</h3><div id=outline-text-headline-66 class=outline-text-3><p>You can now send a test email from your mail server to your Gmail account to see if the SPF and DKIM checks are successful. On the right side of an email opened in Gmail, click the <code class=verbatim>show original</code> button from the drop-down menu to see the verification status:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>SPF:     PASS with IP XXX.XXX.XXX.XXX Learn more
</span></span><span style=display:flex><span>DKIM:    &#39;PASS&#39; with domain example1.com  Learn more
</span></span><span style=display:flex><span>DMARC:   &#39;PASS&#39; Learn more</span></span></code></pre></div></div><p>Our Postfix server also performs SPF and DKIM checks when receiving mail. You can see the results in the headers of the mails you received. E.g:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Received-SPF: Pass (mailfrom) identity=mailfrom; client-ip=2607:f8b0:4864:20::c2d; helo=sender-domain.com; envelope-from=xxx@sender-domain.com; receiver=&lt;UNKNOWN&gt; 
</span></span><span style=display:flex><span>Authentication-Results: example1.com;
</span></span><span style=display:flex><span>	dkim=pass (2048-bit key; unprotected) header.d=sender-domain.com header.i=@sender-domain.com header.b=&#34;XWMRd2co&#34;;
</span></span><span style=display:flex><span>	dkim-atps=neutral</span></span></code></pre></div></div></div></div><div id=outline-container-headline-67 class=outline-3><h3 id=headline-67>Testing Email Score and Placement</h3><div id=outline-text-headline-67 class=outline-text-3><p>You can also go to <a href=https://www.mail-tester.com.>https://www.mail-tester.com.</a> You will see a unique email address. Send an email from your domain to this address to get your score.</p></div></div></div></div><div id=outline-container-headline-68 class=outline-2><h2 id=headline-68>Optional — Block Spam [/]</h2><div id=outline-text-headline-68 class=outline-text-2><div id=outline-container-headline-69 class=outline-3><h3 id=headline-69>Reject Invalid EHLO/HELO Hostname</h3><div id=outline-text-headline-69 class=outline-text-3><p>Some spammers don’t provide a valid <code class=verbatim>HELO/EHLO</code> hostname during SMTP communication. They can be non-fully qualified domain name, or a domain name doesn’t exist or only for an internal network. For example, a spammer using an Amazon EC2 instance to send spam is logged on my server as follows:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Aug 16 04:21:13 email postfix/smtpd[7070]: connect from ec2-54-237-201-103.compute-1.amazonaws.com[54.237.201.103]
</span></span><span style=display:flex><span>Aug 16 04:21:13 email policyd-spf[7074]: prepend Received-SPF: None (mailfrom) identity=mailfrom; client-ip=54.237.201.103; helo=ip-172-30-0-149.ec2.internal; envelope-from=superdiem@carpaythe.tk; receiver=&lt;UNKNOWN&gt;</span></span></code></pre></div></div><p>As you can see, the HELO hostname is <code class=verbatim>ip-172-30-0-149.ec2.internal</code> , which is only valid in AWS internal network. It has no valid A record nor MX record.</p><p>To enable HELO/EHLO hostname restriction, edit Postfix main configuration file:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/postfix/main.cf</span></span></code></pre></div></div><p>Add the following lines to reject SMTP client that does not provide valid HELO/EHLO hostname:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>smtpd_helo_required = yes
</span></span><span style=display:flex><span>smtpd_helo_restrictions =
</span></span><span style=display:flex><span>    permit_mynetworks
</span></span><span style=display:flex><span>    permit_sasl_authenticated
</span></span><span style=display:flex><span>    check_helo_access hash:/etc/postfix/helo_access
</span></span><span style=display:flex><span>    reject_invalid_helo_hostname
</span></span><span style=display:flex><span>    reject_non_fqdn_helo_hostname
</span></span><span style=display:flex><span>    reject_unknown_helo_hostname</span></span></code></pre></div></div><ul><li><code class=verbatim>permit_mynetworks</code>: Allow IPs defined in this directive</li><li><code class=verbatim>permit_sasl_authenticated</code>: Allow authenticated users.</li><li><code class=verbatim>check_helo_access</code>: Allow hostnames defined in this file.</li><li><code class=verbatim>reject_invalid_helo_hostname</code>: Reject clients who provide malformed HELO/EHLO hostname.</li><li><code class=verbatim>reject_non_fqdn_helo_hostname</code>: Reject non-fully qualified HELO/EHLO hostname.</li><li><code class=verbatim>reject_unknown_helo_hostname</code>: Reject email with HELO/EHLO hostname has neither DNS A record nor MX record.</li></ul><p>Now create the file <code class=verbatim>/etc/postfix/helo_access</code> to whitelist domains that do not use a valid hostname:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>optimus-webapi-prod-2.localdomain      OK
</span></span><span style=display:flex><span>va-massmail-02.rakutenmarketing.com    OK</span></span></code></pre></div></div><p>Then run the following command to create the <code class=verbatim>/etc/postfix/helo_access.db</code> file:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postmap /etc/postfix/helo_access</span></span></code></pre></div></div><p>Save and close the file. Then reload Postfix.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl reload postfix</span></span></code></pre></div></div></div></div><div id=outline-container-headline-70 class=outline-3><h3 id=headline-70>Reject Emails from Non-Valid Domains</h3><div id=outline-text-headline-70 class=outline-text-3><p>The <code class=verbatim>MAIL FROM</code> address is also known as <code class=verbatim>envelope from</code> address. Some spammers use a non-existent domain in the <code class=verbatim>MAIL FROM</code> address. If a domain name has no MX record, Postfix will find the A record of the main domain and send email to that host. If the sender domain has neither MX record nor A record, Postfix can’t send email to that domain. So reject those emails that you can’t reply to:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/postfix/main.cf</span></span></code></pre></div></div><p>Make the <code class=verbatim>smtpd_sender_restrictions</code> configuration directive look as follows:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>smtpd_sender_restrictions =
</span></span><span style=display:flex><span>   permit_mynetworks
</span></span><span style=display:flex><span>   permit_sasl_authenticated
</span></span><span style=display:flex><span>   reject_unknown_sender_domain</span></span></code></pre></div></div><ul><li><code class=verbatim>reject_unknown_sender_domain</code>: Checks the sender's email domain in the <code class=verbatim>MAIL FROM</code> address to ensure it has a valid DNS configuration. It requires that the domain in the sender's email address has a valid MX or A record.</li></ul><p>Then restart Postfix for the change to take effect:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl restart postfix</span></span></code></pre></div></div></div></div><div id=outline-container-headline-71 class=outline-3><h3 id=headline-71>Reject Emails if No Valid PTR or A Record for Hostname</h3><div id=outline-text-headline-71 class=outline-text-3><p>A legitimate email server should have a PTR record and a valid A record for its hostname. The IP address returned from DNS A record should match the IP address of the contacting email server. So tell Postfix to perform these checks on SMTP client server:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/postfix/main.cf</span></span></code></pre></div></div><p>Make the <code class=verbatim>smtpd_sender_restrictions</code> configuration directive look as follows:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>smtpd_sender_restrictions =
</span></span><span style=display:flex><span>   permit_mynetworks
</span></span><span style=display:flex><span>   permit_sasl_authenticated
</span></span><span style=display:flex><span>   reject_unknown_sender_domain
</span></span><span style=display:flex><span>   reject_unknown_reverse_client_hostname
</span></span><span style=display:flex><span>   reject_unknown_client_hostname</span></span></code></pre></div></div><ul><li><code class=verbatim>reject_unknown_reverse_client_hostname</code>: Checks the reverse DNS (PTR record) of the client’s IP address (the IP of the server connecting to your Postfix server) to ensures that the IP address of the sending server can be mapped back to a valid hostname.</li><li><code class=verbatim>reject_unknown_client_hostname</code>: Performs a check that the hostname obtained from the PTR record has a valid forward DNS (A record) pointing back to the SMTP server that connecting to your Postfix server.</li></ul><p>Save and close the file. Then restart Postfix for the change to take effect.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl restart postfix</span></span></code></pre></div></div></div></div><div id=outline-container-headline-72 class=outline-3><h3 id=headline-72>Greylisting</h3><div id=outline-text-headline-72 class=outline-text-3><div id=outline-container-headline-73 class=outline-4><h4 id=headline-73>Introduction</h4><div id=outline-text-headline-73 class=outline-text-4><p>Greylisting is a spam prevention technique that can be implemented in Postfix to reduce unwanted email by temporarily rejecting new email senders and requiring them to retry. Because most legitimate mail servers will retry delivery after a short delay, while many spam servers or bots will not attempt to resend.</p><p><strong>How Greylisting Works ?</strong></p><ol><li>Initial Rejection: When an email is received from an unfamiliar sender IP, sender address, and recipient address combination, Postfix temporarily rejects it with a <code class=verbatim>451</code> (Temporary failure) response. This tells the sending server to try again later.</li><li>Retry Attempt: If the sending server retries after a certain period, Postfix recognizes the retry as legitimate and accepts the email.</li><li>Temporary Listing: After accepting the email, Postfix remembers this sender-recipient combination for a configurable period, so subsequent emails from this source are accepted without delay.</li></ol></div></div><div id=outline-container-headline-74 class=outline-4><h4 id=headline-74>Configuration</h4><div id=outline-text-headline-74 class=outline-text-4><p>Postgrey is a greylisting policy server for Postfix. So first install install postgrey:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo apt install postgrey</span></span></code></pre></div></div><p>Start and enable it with systemctl:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl start postgrey
</span></span><span style=display:flex><span>  sudo systemctl enable postgrey</span></span></code></pre></div></div><p>On Debian and Ubuntu, it listens on TCP port 10023 on localhost:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo netstat -lnpt | grep postgrey</span></span></code></pre></div></div><p>Next, we need to edit Postfix main configuration file to make it use the greylisting policy server.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/postfix/main.cf</span></span></code></pre></div></div><p>Add the line <code class=verbatim>check_policy_service inet:127.0.0.1:10023</code> to <code class=verbatim>smtpd_recipient_restrictions</code> configuration directive:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>smtpd_recipient_restrictions =
</span></span><span style=display:flex><span>   reject_unauth_destination,
</span></span><span style=display:flex><span>   check_policy_service unix:private/quota-status,
</span></span><span style=display:flex><span>   check_policy_service unix:private/policyd-spf,
</span></span><span style=display:flex><span>   check_policy_service inet:127.0.0.1:10023</span></span></code></pre></div></div><p>Then restart Postfix.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl restart postfix</span></span></code></pre></div></div><p>From now on, Postgrey will reject an email if the sender triplet (sender IP address, sender email address, recipient email address) is new. The following log message in <code class=verbatim>/var/log/mail.log</code> (or <code>sudo journalctl -u postgrey</code>) shows a new sender triplet. The action <code class=verbatim>greylist</code> means this email message was rejected:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>postgrey[1016]: action=greylist, reason=new, client_name=unknown, client_address=117.90.24.148/32, sender=pnccepjeu@rhknqj.net, recipient=xiao@linuxbabe.com</span></span></code></pre></div></div></div></div><div id=outline-container-headline-75 class=outline-4><h4 id=headline-75>Whitelist Domains</h4><div id=outline-text-headline-75 class=outline-text-4><p>Greylisting can result in bad experience for the end user, as the user has to wait another several minute for the email to arrive. To minimize this bad experience, you can create a whitelist, and use a second MX record that points to the same host.
Whitelist</p><p>Postgrey ships with two whitelist files (<code class=verbatim>/etc/postgrey/whitelist_clients</code> and <code class=verbatim>/etc/postgrey/whitelist_recipients</code>). The former contains a list of hostnames and the latter contains a list of recipient addresses.</p><p>By default, Google’s mail servers are whitelisted. No matter the sender is using a <code class=verbatim>@gmail.com</code> address or other address, as long as the sender is using Google’s mail server, Postgrey won’t reject the email. The following line in my <code class=verbatim>/var/log/mail.log</code> file shows this:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>postgrey[1032]: action=pass, reason=client whitelist, client_name=mail-yb0-f190.google.com</span></span></code></pre></div></div><p>You can add other hostnames in <code class=verbatim>/etc/postgrey/whitelist_clients</code> file, like:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>facebook.com
</span></span><span style=display:flex><span>bounce.twitter.com
</span></span><span style=display:flex><span>blogger.com
</span></span><span style=display:flex><span>email.medium.com</span></span></code></pre></div></div><p>Now let's create a secondary MX record in DNS with the same IP address pointing to your same Potfix server to allow the SMTP client to retry immediately after the first mail server rejects the mail. For example:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Record Type    Name      Mail Server            Priority
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MX             @         mail1.example1.com     0
</span></span><span style=display:flex><span>MX             @         mail2.example1.com     5</span></span></code></pre></div></div><p>The sender will try the first mail server (with priority 0). If <code class=verbatim>mail1.example1.com</code> rejects email by greylisting, then the sender would immediately try the second mail server (with priority 5).</p><p>Since two mail server hostnames have the same IP address, when the sender tries the second mail server hostname, the email will be accepted immediately (if all other checks pass) and end users will not notice the email delay caused by greylisting.</p><p>Note that this requires you to set a very small delay time like 1 second in <code class=verbatim>/etc/default/postgrey</code>. The delay time tells the SMTP client how many seconds to wait before sending again. If the delay time is not small enough, then the second email delivery would still be rejected:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>POSTGREY_OPTS=&#34;--inet=127.0.0.1:10023 --delay=1&#34;</span></span></code></pre></div></div><p>Finally restart Postgrey:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl restart postgrey</span></span></code></pre></div></div></div></div><div id=outline-container-headline-76 class=outline-4><h4 id=headline-76>Troubleshooting</h4><div id=outline-text-headline-76 class=outline-text-4><p>If you see the following error in mail log (<code class=verbatim>/var/log/mail.log</code>)</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>warning: connect to 127.0.0.1:10023: Connection refused
</span></span><span style=display:flex><span>warning: problem talking to server 127.0.0.1:10023: Connection refused</span></span></code></pre></div></div><p>The problem is that postgrey is not running. You need to specify 127.0.0.1 as the listening address in /etc/default/postgrey file. So change the following line:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>POSTGREY_OPTS=&#34;--inet=10023&#34;</span></span></code></pre></div></div><p>to</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>POSTGREY_OPTS=&#34;--inet=127.0.0.1:10023&#34;</span></span></code></pre></div></div><p>Then restart postgrey:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl restart postgrey</span></span></code></pre></div></div><p>Check if it’s listening:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  sudo netstat -lnpt | grep 10023</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-77 class=outline-3><h3 id=headline-77>Use Public Realtime Blacklists</h3><div id=outline-text-headline-77 class=outline-text-3><p>There are spam emails that are sent from servers that has a valid hostname, valid PTR record and can pass all previous checks. In this case, you can use blacklisting to reject spam. There are many public realtime blacklists (RBL), also known as DNSBLs (DNS based lists). By realtime it means that the list is always changing. An IP address or domain name could be on the list today and off the list tomorrow, so you could get different result depending on when you query the list.</p><p>You can use multiple blacklists to block spam. Go to <a href=https://www.debouncer.com>www.debouncer.com</a> and <a href=https://mxtoolbox.com>mxtoolbox.com</a>, enter the spammer’s domain and/or IP address to see which blacklists are blocking them, then you can use those blacklists. For example, I found that spammers are blacklisted by one of the following blacklists:</p><ul><li>dbl.spamhaus.org</li><li>zen.spamhaus.org</li><li>multi.uribl.com</li><li>ivmURI</li><li>InvaluementURI</li></ul><p>So I can add the following configurations in <code class=verbatim>/etc/postfix/main.cf</code> file. Some public blacklisting service requires monthly fee. For now, I’m using the free service of spamhaus.org:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>smtpd_recipient_restrictions =
</span></span><span style=display:flex><span>   permit_mynetworks,
</span></span><span style=display:flex><span>   permit_sasl_authenticated,
</span></span><span style=display:flex><span>   check_policy_service unix:private/policyd-spf,
</span></span><span style=display:flex><span>   check_policy_service inet:127.0.0.1:10023,
</span></span><span style=display:flex><span>   check_client_access hash:/etc/postfix/rbl_override,
</span></span><span style=display:flex><span>   reject_rhsbl_helo dbl.spamhaus.org,
</span></span><span style=display:flex><span>   reject_rhsbl_reverse_client dbl.spamhaus.org,
</span></span><span style=display:flex><span>   reject_rhsbl_sender dbl.spamhaus.org,
</span></span><span style=display:flex><span>   reject_rbl_client zen.spamhaus.org</span></span></code></pre></div></div><ul><li><code class=verbatim>check_client_access</code>: File containing a list of domains you want to whitelist.</li><li><code class=verbatim>reject_rhsbl_helo</code>: Postfix reject email when the client HELO/EHLO hostname is blacklisted.</li><li><code class=verbatim>reject_rhsbl_reverse_client</code>: Checks the PTR (reverse DNS) record of the SMTP client’s IP address against Spamhaus's DBL. If the hostname is blacklisted, reject the email.</li><li><code class=verbatim>reject_rhsbl_sender</code> Postfix reject email when the domain in <code class=verbatim>MAIL FROM</code> header field is blacklisted.</li><li><code class=verbatim>reject_rbl_client</code>: This is an IP-based blacklist. When the client IP address is backlisted, reject the email.</li></ul><p><em>NOTE: Some spammers use Google’s mail server, so <code class=verbatim>reject_rhsbl_helo</code> is ineffective, but most of them use their own domain names in the <code class=verbatim>MAIL FROM</code> header field, so <code class=verbatim>reject_rhsbl_sender</code> will be effective.</em></p><p>Sometimes legitimate mail servers are blacklisted. In this case, we ask the Postfix server to whitelist these domains by listing them in a file:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo nano /etc/postfix/rbl_override</span></span></code></pre></div></div><p>Add the domains you want to whitelist:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>dripemail2.com  OK           //This domain belongs to drip.com
</span></span><span style=display:flex><span>mlsend.com      OK           //This domain belongs to mailerlite email marketing service</span></span></code></pre></div></div><p>Then run the following command to create the <code class=verbatim>rbl_override.db</code> file.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo postmap /etc/postfix/rbl_override</span></span></code></pre></div></div><p>Reload Postfix for the changes to take effect.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo systemctl reload postfix</span></span></code></pre></div></div></div></div><div id=outline-container-headline-78 class=outline-3><h3 id=headline-78>Use Public Whitelist to Reduce False Positive</h3><div id=outline-text-headline-78 class=outline-text-3><p>Maintaining a private whitelist is necessary sometimes, but you can also use public whitelists, the most famous of which is <a href=https:dnswl.org>dnswl.org</a>. Currently, there is only a whitelist for IP address. Domain name whitelist is in beta. To use it, put the following line in <code class=verbatim>smtpd_recipient_restrictions</code>.</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>permit_dnswl_client list.dnswl.org=127.0.[0..255].[1..3],</span></span></code></pre></div></div><p>Like below. It should be placed above the reject_rbl_client check.</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>smtpd_recipient_restrictions =
</span></span><span style=display:flex><span>   permit_mynetworks,
</span></span><span style=display:flex><span>   permit_sasl_authenticated,
</span></span><span style=display:flex><span>   check_policy_service unix:private/policyd-spf,
</span></span><span style=display:flex><span>   check_policy_service inet:127.0.0.1:10023,
</span></span><span style=display:flex><span>   check_client_access hash:/etc/postfix/rbl_override,
</span></span><span style=display:flex><span>   reject_rhsbl_helo dbl.spamhaus.org,
</span></span><span style=display:flex><span>   reject_rhsbl_reverse_client dbl.spamhaus.org,
</span></span><span style=display:flex><span>   reject_rhsbl_sender dbl.spamhaus.org,
</span></span><span style=display:flex><span>   permit_dnswl_client list.dnswl.org=127.0.[0..255].[1..3],
</span></span><span style=display:flex><span>   reject_rbl_client zen.spamhaus.org</span></span></code></pre></div></div><p>Another well-known whitelist is <code class=verbatim>swl.spamhaus.org</code>, so you can also add it below the <code class=verbatim>permit_dnswl_client list.dnswl.org=127.0.[0..255].[1..3],</code> line:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>permit_dnswl_client swl.spamhaus.org,</span></span></code></pre></div></div><p>It’s impossible for an IP address to be listed in Spamhaus whitelist and blacklist at the same time, so if you only use Spamhaus blacklist in Postfix, then it’s not necessary to check against Spamhaus whitelist.</p></div></div><div id=outline-container-headline-79 class=outline-3><h3 id=headline-79><span class=todo>TODO</span>
Anti-spam — SpamAssassin</h3><div id=outline-text-headline-79 class=outline-text-3><ul><li>State "TODO" from [2024-11-02 Sat 17:45]</li></ul><p>Run the following command to install SpamAssassin from the default Debian/Ubuntu software repository. Spamc is the client for SpamAssassin spam filtering daemon.</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt install spamassassin spamc</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-80 class=outline-2><h2 id=headline-80>Tips/Tricks</h2><div id=outline-text-headline-80 class=outline-text-2><div id=outline-container-headline-81 class=outline-3><h3 id=headline-81>How to Read Postfix Log ?</h3><div id=outline-text-headline-81 class=outline-text-3><p>Open a new terminal and read the log continuously:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo tail -f /var/log/mail.log</span></span></code></pre></div></div><p>While reading the log file, open a new terminal on the SMTP server and send a test mail:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  swaks --to user1@example1.com --server localhost</span></span></code></pre></div></div><p>If all works as expected your <code class=verbatim>mail.log</code> will show a lot of technical information about the email delivery:</p><ul><li><code class=verbatim>postfix/smtpd[29225]: connect from localhost.localdomain[127.0.0.1]</code>
Postfix receives an incoming SMTP connection.</li><li><code class=verbatim>postfix/smtpd[29225]: *8BA46A0A3A*: client=localhost.localdomain[127.0.0.1]</code>
Postfix assigns a unique identifier (8BA46A0A3A) to this connection so that you see which log lines belong together. This is especially important with busy mail servers where multiple mails are handled in parallel.</li><li><code class=verbatim>postfix/cleanup[29233]: 8BA46A0A3A: message-id=20191126153053.029243@example1.com</code></li></ul><p>Swaks created a unique message id to the email which helps you identify specific mails in the log file.</p><ul><li><code class=verbatim>postfix/qmgr[13667]: 8BA46A0A3A: from=root@webmail.example.org, size=485, nrcpt=1 (queue active)</code>
The sender was <code class=verbatim>root@example.org</code>. This is logged after swaks sent the <code class=verbatim>MAIL FROM</code> line during the SMTP dialog.</li><li><code class=verbatim>postfix/smtpd[29225]: disconnect from localhost.localdomain[127.0.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5</code>
The SMTP communication ends. Postfix has now received and queued the email.</li><li><code class=verbatim>dovecot: lmtp(29237): Connect from local</code>
Postfix connects to Dovecot to hand over the email via the LMTP interface.</li><li><code class=verbatim>dovecot: lmtp(user1@example.com)&lt;29237>&lt;2PJTIh033V01cgAARGEcaw>: sieve: msgid=20191126153053.029243@example.org: stored mail into mailbox 'INBOX.test'</code>
Dovecot received the email and even evaluated User1’s sieve rule which made the email get stored to the <code class=verbatim>test</code> folder of his mailbox.</li><li><code class=verbatim>dovecot: lmtp(29237): Disconnect from local: Client has quit the connection (state=READY)</code>
The LMTP connection between Postfix and Dovecot is closed.</li><li><code class=verbatim>postfix/lmtp[29236]: 8BA46A0A3A: to=user1@example.com, relay=example.com[private/dovecot-lmtp], delay=0.01, delays=0/0/0/0.01, dsn=2.0.0, status=sent (250 2.0.0 user1@example1.com 2PJTIh033V01cgAARGEcaw Saved)</code>
This tells you what happened with a certain email. In this case it says that it was handed over to <code class=verbatim>dovecot-lmtp</code> and that the delivery was successful (<code class=verbatim>status=sent</code>). The status codes like <code class=verbatim>2.0.0</code> are defined in RFC 3463 and work similar to status codes in HTTP. Codes beginning with "2" are good. Those with "4" are temporary errors. And "5" stands for a permanent failure.</li></ul></div></div><div id=outline-container-headline-82 class=outline-3><h3 id=headline-82>Postfix Log Report</h3><div id=outline-text-headline-82 class=outline-text-3><ul><li>State "TODO" from [2024-11-02 Sat 17:47]</li></ul><p>Pflogsumm is a great tool to create a summary of Postfix logs. Install it:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo apt install pflogsumm</span></span></code></pre></div></div><p>Generate a report for this week:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo pflogsumm /var/log/mail.log</span></span></code></pre></div></div><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td><code>-d today</code></td><td>Generate a report for today</td></tr><tr><td><code>-d yesterday</code></td><td>Generate a report for yesterday</td></tr><tr><td><code>--problems-first</code></td><td>Add <code class=verbatim>problem</code> reports (bounces, defers, warnings, rejects) before <code class=verbatim>normal</code> stats use</td></tr><tr><td><code>--rej-add-from</code></td><td>Append the email from address to each listing in the reject report</td></tr><tr><td><code>--verbose-msg-detail</code></td><td>Show the full reason in reject summaries</td></tr></tbody></table><p>You can add a cron job to make pflogsumm to send a report to your email address every day:</p><div class="src src-shell"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  sudo crontab -e</span></span></code></pre></div></div><p>Add the following line, which will generate a report every day at 4:00 am and send it to your email address:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0 4 * * * /usr/sbin/pflogsumm -d yesterday /var/log/mail.log --problems-first --rej-add-from --verbose-msg-detail -q MAILTO=&#34;your-email-address&#34;</span></span></code></pre></div></div><p><strong>CAREFUL: Make sure to replace <code class=verbatim>your-email-address</code> with your real email address</strong></p></div></div></div></div><div id=outline-container-headline-83 class=outline-2><h2 id=headline-83>Footnotes</h2></div><div class=footnotes><hr class=footnotes-separatator><div class=footnote-definitions><div class=footnote-definition><sup id=footnote-1><a href=#footnote-reference-1>1</a></sup><div class=footnote-body><p>Namespaces - <a href=https://doc.dovecot.org/2.3/configuration_manual/namespace/>https://doc.dovecot.org/2.3/configuration_manual/namespace/</a></p></div></div><div class=footnote-definition><sup id=footnote-2><a href=#footnote-reference-2>2</a></sup><div class=footnote-body><p>Quota - <a href=https://doc.dovecot.org/2.3/configuration_manual/quota/>https://doc.dovecot.org/2.3/configuration_manual/quota/</a></p></div></div><div class=footnote-definition><sup id=footnote-3><a href=#footnote-reference-3>3</a></sup><div class=footnote-body><p>Quota Plugin - <a href=https://doc.dovecot.org/2.3/configuration_manual/quota_plugin/>https://doc.dovecot.org/2.3/configuration_manual/quota_plugin/</a></p></div></div><div class=footnote-definition><sup id=footnote-4><a href=#footnote-reference-4>4</a></sup><div class=footnote-body><p>Quota Backend: count - <a href=https://doc.dovecot.org/2.3/configuration_manual/quota/quota_count/#quota-backend-count>https://doc.dovecot.org/2.3/configuration_manual/quota/quota_count/#quota-backend-count</a></p></div></div><div class=footnote-definition><sup id=footnote-5><a href=#footnote-reference-5>5</a></sup><div class=footnote-body><p>SMTP Service Extension for Returning Enhanced Error Codes - <a href=https://datatracker.ietf.org/doc/html/rfc2034>https://datatracker.ietf.org/doc/html/rfc2034</a></p></div></div><div class=footnote-definition><sup id=footnote-6><a href=#footnote-reference-6>6</a></sup><div class=footnote-body><p>Test DKIM - <a href=https://www.mimecast.com/products/dmarc-analyzer/dkim-check/>https://www.mimecast.com/products/dmarc-analyzer/dkim-check/</a></p></div></div></div></div></main><footer><hr>© <a href=https://www.atomicl.net>Vithurshan SELVARAJAH</a> 2022 &ndash; 2025 | <a href=https://github.com/BlackcatRs>Github</a> | <a href=https://www.linkedin.com/in/vithurshan-selvarajah/>LinkedIn</a></footer></body></html>